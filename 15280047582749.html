<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	轮播图 - 
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html"></a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">轮播图</h1>
		<div class="entry-content" itemprop="articleBody">
			<h3 id="toc_0">实现思路</h3>

<p>1.1: 三个视图，中间的视图用于显示当前播放的图片，左右的视图用于向左向右切换。</p>

<p>1.2: 无限循环的数学思路，以五张图片为例，<code>1</code> &lt;-&gt; <code>2</code> &lt;-&gt; <code>3</code> &lt;-&gt; <code>4</code> &lt;-&gt; <code>5</code> &lt;-&gt; <code>1</code> ... &lt;-&gt;<code>5</code>, 也就是第一张图片向左可以切换到最后一张图片，最后一张图片向右可以切换到第一张图片，然后中间的图片是连续的。我们设有总共有M张图片，那么很容易得到数列 <code>{Sn = (Sn-1 + 1) % M ， S1 = 1，S2 = 2}</code>  也就是说中间的图片是左边的图片 + 1 然后对总图片数取余。</p>

<p>1.3: 一个切换过程的细节，我们以播放下一张为例，当中间的视图被右边的视图切换掉后，此时显示的是过渡视图，我们将左边和中间视图的显示内容向又移动一个单元，也就是说中间的视图和右边的过渡视图此时是一样的，然后改变滚动视图的显示区域，把视图滚动到中间，也就是中间的视图在此霸占了显示区域，重新记录一下我们显示到了第几张图片，以便下次我们切换图片。这样就完成了一个切换，向左切换也是同理。</p>

<h3 id="toc_1">下面是iOS 的实现细节</h3>

<p><img src="media/15280047582749/15280105400096.jpg" alt=""/><br/>
1.主题部分：<br/>
 1.1: bodyView 承载三个 UIImageView, centerImageView 是当前展示的内容，leftImageView和rightImageView负责左右切换的时候显示,切换完成后要还原到centerImageView， 也就以centerImageView 为中心。<br/>
 1.2: page 记录当前滑动到了第几张了，每一次滑动，都会切换三张图片。如刚开始是 <code>1,2,3</code> 向右一个单元后图片变成了 <code>2,3,4</code>,这个page 在每次切换前后都会是起到参考的作用。<br/>
 1.3: imgesCount 图片的总张数， loopSpace: 轮播图的播放间隔，timer 用于自动播放。</p>

<pre><code>@interface QKLoopBanner () &lt;UIScrollViewDelegate&gt;

@property (nonatomic,strong) UIScrollView *bodyView;
@property (nonatomic,strong) UIImageView *leftImageView;
@property (nonatomic,strong) UIImageView *centerImageView;
@property (nonatomic,strong) UIImageView *rightImageView;
@property (nonatomic,strong) UIPageControl *pageControl;

@property (nonatomic,assign) NSUInteger page;
@property (nonatomic,assign) NSUInteger imgesCount;
@property (nonatomic,assign)NSTimeInterval loopSpace;

@property (nonatomic,strong)NSTimer *timer;
@end
</code></pre>

<p>2 播放器和其他类的交互<br/>
2.1: 统一采用代理设计模式，图片点击放在QKLoopBannerDelegate中，点击图片后，会把当前的轮播图（考虑到一个地方可能会有几个轮播图）、当前的显示视图、第几张图片的序号</p>

<pre><code>@class QKLoopBanner;

@protocol QKLoopBannerDelegate &lt;NSObject&gt;

@optional
- (void)loopBanner:(QKLoopBanner *)loopBanner
   didSelectedItem:(UIImageView *)imageView
             index:(NSUInteger)index;

@end
</code></pre>

<p>2.2 轮播图数据源方法<br/>
1. 获取轮播图的总张数<br/>
2. loopBanner:reloadImageView:index 刷新第index张图片，一般会连着调用三次，由于一次轮播。<br/>
3. pageControlOfloopBanner 自定义轮播指示器，如果不想要指示器返回nil就好。<br/>
4. chanedPage 实时报告当前的位置</p>

<pre><code>@protocol QKLoopBannerDataSource &lt;NSObject&gt;

@required
- (NSUInteger)numberOfImagesInLoopBanner:(QKLoopBanner *)loopBanner;
- (void)loopBanner:(QKLoopBanner *)loopBanner
   reloadImageView:(UIImageView *)imageView
             index:(NSUInteger)index;

@optional
- (void)loopBanner:(QKLoopBanner *)loopBanner
        chanedPage:(NSUInteger)page;
- (UIPageControl *)pageControlOfloopBanner:(QKLoopBanner *)loopBanner;

@end
</code></pre>

<p>3 轮播图开放的API<br/>
3.1 initWithFrame:loopSpace 初始化，loopSpace 自动播放时间间隔<br/>
3.2 delegate 交互代理，dataSource 轮播图数据源，数据源必须实现，不然是空白的。<br/>
3.3 reloadData : 当改变了轮播图的张数或者轮播图的具体内容，需要reloadData 重载一下数据。</p>

<pre><code>@interface QKLoopBanner : UIView

- (instancetype)initWithFrame:(CGRect)frame
                    loopSpace:(NSTimeInterval )loopSpace;
- (void)reloadData;


@property (nonatomic,assign) id &lt;QKLoopBannerDelegate&gt; delegate;
@property (nonatomic,assign) id &lt;QKLoopBannerDataSource&gt; dataSource;

@end
</code></pre>

<p>4 实现的具体细节</p>

<pre><code>4.1 通过 dataSource 获取图片张数
- (void)setDataSource:(id&lt;QKLoopBannerDataSource&gt;)dataSource {
    
    _dataSource = dataSource;
    if (_dataSource) {
        self.imgesCount = [dataSource numberOfImagesInLoopBanner:self];
    }
    
}
</code></pre>

<pre><code>4.2 处理 0,1, &gt;1 张的图片
- (void)setImgesCount:(NSUInteger)imgesCount {
    _imgesCount = imgesCount;
    _page = 0;
    switch (imgesCount) {
        case 0:
        {
            //没有图片的情况下，清空所有，不可交互
            [self.leftImageView setImage:nil];
            [self.centerImageView setImage:nil];
            [self.rightImageView setImage:nil];
            [self.bodyView setScrollEnabled:NO];
            [self.centerImageView setUserInteractionEnabled:NO];
            if (self.pageControl) {
                [self.pageControl removeFromSuperview];
                self.pageControl = nil;
            }
        }
            break;
        case 1:
        {
            //只有一张图片的情况下，让中间的视图显示图片，没有自动播放，不可滚动，但是可以点击
            [self.centerImageView setImage:nil];
            [self.rightImageView setImage:nil];
            [self changeToCenter];
            [self.dataSource loopBanner:self
                        reloadImageView:self.centerImageView
                                  index:0];
            [self.centerImageView setUserInteractionEnabled:YES];
            [self.bodyView setScrollEnabled:NO];
            if (self.pageControl) {
                [self.pageControl removeFromSuperview];
                self.pageControl = nil;
            }
        }
            break;
            
        default:
        {
            // 多余一张图片的时候，让中间的显示第一张
            // 让左边的显示最后一张，右边的显示下一张
            // bodyView的视野是中间的那个
            // 播放间隔后自动到下一张
            [self.bodyView setScrollEnabled:YES];
            [self.dataSource loopBanner:self
                        reloadImageView:self.rightImageView
                                  index:imgesCount-1];
            [self.dataSource loopBanner:self
                        reloadImageView:self.centerImageView
                                  index:0];
            [self.dataSource loopBanner:self
                        reloadImageView:self.rightImageView
                                  index:1];
            if ([self.dataSource respondsToSelector:@selector(loopBanner:chanedPage:)]) {
                [self.dataSource loopBanner:self chanedPage:_page];
            }
            [self.centerImageView setUserInteractionEnabled:YES];
            [self.timer setFireDate:[NSDate dateWithTimeIntervalSinceNow:self.loopSpace]];
            if ([self.dataSource respondsToSelector:@selector(pageControlOfloopBanner:)]) {
                self.pageControl = [self.dataSource pageControlOfloopBanner:self];
                [self addSubview:self.pageControl];
                [self.pageControl setNumberOfPages:imgesCount];
            }
        }
            break;
    }
}


</code></pre>

<pre><code>4.3 观察bodyView滚动的位置，当到左边或者右边的时候需要处理
- (void)addObservers {
    [self.bodyView addObserver:self
                    forKeyPath:@&quot;contentOffset&quot;
                       options:NSKeyValueObservingOptionNew
                       context:nil];
}


- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary&lt;NSString *,id&gt; *)change
                       context:(void *)context {
    if ([keyPath isEqualToString:@&quot;contentOffset&quot;]) {
        [self caculatePage];
    }
}

</code></pre>

<p>很关键的点，图片切换前夜 —— 位置计算<br/>
1. criticalValue 为一个很小的正数，这个点子很微妙，说出来就没有韵味了，留给大家慢慢体会。O(∩_∩)O哈哈~<br/>
2. X 坐标 &gt; 2 * CGRectGetWidth(self.bodyView.bounds) 说明是 从中间跑到了 右边， 所以是播放下一张<br/>
3. X 坐标是一个很小的正数，说明已经到第一张了</p>

<pre><code>- (void)caculatePage {
    if (self.imgesCount &gt; 0) {
        CGFloat pointX = self.bodyView.contentOffset.x;
        
        // judge critical value，first and third imageView&#39;s contentoffset
        // last to first or first to last
        CGFloat criticalValue = .2f;
        
     
        if (pointX &gt; 2 * CGRectGetWidth(self.bodyView.bounds) - criticalValue) {
            //centerImage to rightImage(next page)
            // {An | Sn = 1,2,3...n} == {An | Sn = n}
            // {Bn | Sn = 2,3,..n,1} == {Bn | Sn = (n + 1)%n }
            self.page = (self.page + 1) % self.imgesCount;
        } else if (pointX &lt; criticalValue) {
            //scroll to leftImage(previous page)
            // + self.imgesCount mod case for self.page == 0
            self.page = (self.page + self.imgesCount - 1) % self.imgesCount;
        }
    }
}
</code></pre>

<p>图片切换进行时<br/>
1.通过page，刷新左中右视图的显示<br/>
2.把中间的那个视图继续变到中间</p>

<pre><code>- (void)setPage:(NSUInteger)page {
    _page = page;
    NSUInteger leftIndex = (_page + self.imgesCount - 1) % self.imgesCount;
    NSUInteger rightIndex= (_page + 1) % self.imgesCount;
    [self.dataSource loopBanner:self
                reloadImageView:self.leftImageView
                          index:leftIndex];
    [self.dataSource loopBanner:self
                reloadImageView:self.centerImageView
                          index:_page];
    [self.dataSource loopBanner:self
                reloadImageView:self.rightImageView
                          index:rightIndex];
    if ([self.dataSource respondsToSelector:@selector(loopBanner:chanedPage:)]) {
        [self.dataSource loopBanner:self chanedPage:_page];
    }
    [self changeToCenter];
    [self.pageControl setCurrentPage:_page];
}
</code></pre>

<p>自动播放核心<br/>
1.如果中间的视图不在bodyView的视野，先调过来。<br/>
2.从中间位置切换到右边</p>

<pre><code> CGFloat criticalValue = .2f;
    if (self.bodyView.contentOffset.x &lt; CGRectGetWidth(self.bodyView.bounds) - criticalValue || self.bodyView.contentOffset.x &gt; CGRectGetWidth(self.bodyView.bounds) + criticalValue) {
        [self changeToCenter];
    }
    CGPoint newOffset = CGPointMake(self.bodyView.contentOffset.x + CGRectGetWidth(self.bodyView.bounds), self.bodyView.contentOffset.y);
    [self.bodyView setContentOffset:newOffset animated:YES];
</code></pre>

<p>最后，使用到了NSTimer，在轮播图需要释放前，需要先暂停timer，不然会造成内存泄露，切记，在 dealoc 里边是释放不了timer的。内存相关代码如下。</p>

<pre><code>- (void)removeFromSuperview {
    if (self.timer) {
        [self.timer invalidate];
        self.timer = nil;
    }
}
- (void)dealloc {
    [self removeObservers];
}
</code></pre>

		</div>
	</article>
	<div class="share-comment">
	
	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>
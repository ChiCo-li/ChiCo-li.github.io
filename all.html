<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	
  	
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html"></a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-05T21:00:56+08:00" itemprop="datePublished">2018/6/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15282036563173.html" itemprop="url">
		汇编指令练习</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">bl指令</h3>

<ul>
<li>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令</li>
<li>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如

<ul>
<li>mov x0,#10、mov x1,#20</li>
</ul></li>
<li><p>但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p></li>
<li><p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p></li>
</ul>

<h3 id="toc_1">bl指令 -- 练习</h3>

<p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p>

<pre><code>_A:
    mov x0,#0xa0
    mov x1,#0x00
    add x1, x0, #0x14
    mov x0,x1
    bl _B
    mov x0,#0x0
    ret

_B:
    add x0, x0, #0x10
    ret
</code></pre>

<p><img src="media/15282036563173/15282051792907.jpg" alt=""/></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-05T15:10:29+08:00" itemprop="datePublished">2018/6/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15281826293684.html" itemprop="url">
		汇编与硬件</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">总线</h3>

<ul>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互</li>
<li>总线：一根根导线的集合</li>
<li><p>总线的分类</p>

<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul></li>
<li><p><strong>地址总线</strong></p>

<ul>
<li>它的宽度决定了CPU的<u>寻址能力</u></li>
<li>8086的地址总线宽度是<u>20</u>，所以寻址能力是<u>1M</u>（ 2<sup>20</sup>  ）</li>
</ul></li>
<li><p><strong>数据总线</strong></p>

<ul>
<li>它的宽度决定了CPU的单次数据传送量，也就是数据<u>传送速度</u></li>
<li>8086的数据总线宽度是<u>16</u>，所以单次最大传递<u>2个字节</u>的数据</li>
</ul></li>
<li><p><strong>控制总线</strong></p>

<ul>
<li>它的宽度决定了CPU对其他器件的<u>控制能力</u>、能有多少种控制</li>
</ul></li>
</ul>

<p><strong>做个小练习</strong><br/>
* 一个CPU 的寻址能力为8KB,那么它的地址总线的宽度为？</p>

<blockquote>
<p>8KB = 2<sup>3KB</sup> = 2<sup>3</sup> * 2<sup>10</sup> Byte = 2<sup>13</sup> Byte<br/>
8KB 的地址总线宽度为13<br/>
注意：内存的最小的存储单位是Byte，而不是一个bit，也就是说一个地址线可以访问1Byte的空间</p>
</blockquote>

<ul>
<li>8080,8088,80286,80386 的<strong>地址总线</strong>宽度分别为16根,20根,24根,32根.那么他们的寻址能力分别为多少____KB, ____MB,____MB,____GB?</li>
</ul>

<blockquote>
<p>1KB = 2<sup>10</sup> Byte  =&gt; 2<sup>16</sup> Byte = 2<sup>10</sup> * 2<sup>6</sup> Byte = 2<sup>6</sup> KB = 64KB<br/>
1 MB = 2<sup>10</sup> KB = 2<sup>10</sup> * 2<sup>10</sup> Byte = 2<sup>20</sup> Byte<br/>
2<sup>24</sup> Byte = 2<sup>20</sup> * 2<sup>4</sup> Byte = 2<sup>4</sup> MB = 16MB<br/>
1 GB = 2<sup>10</sup> MB = 2<sup>10</sup> * 2<sup>20</sup> Byte = 2<sup>30</sup> Byte ==&gt; 2<sup>32</sup> Byte = 2<sup>2</sup> GB = 4GB</p>
</blockquote>

<ul>
<li>8080,8088,8086,80286,80386 的<strong>数据总线</strong>宽度分别为8根,8根,16根,16根,32根.那么它们一次可以传输的数据为:____B,____B,____B,____B,____B</li>
</ul>

<blockquote>
<p>注意，地址总线用于寻址，而一个地址存的是一个Byte大小的数据<br/>
数据总线用于传递数据，一个数据总线可以传一个二进制的数据，0或者1，所以是一个bite<br/>
数据总线的传输率是所有线路量之和<br/>
8bit = 1Byte<br/>
16Bit = 2Byte <br/>
32Bit = 4Byte</p>
</blockquote>

<ul>
<li>从内存中读取1024字节的数据,8086至少要读____次,80386至少要读取____次.
&gt; 8086 需要 1024 / 2 = 512 次
&gt; 80386 至少需要 1024/4 = 256 次</li>
</ul>

<h3 id="toc_1">内存</h3>

<ul>
<li><p>内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2<sup>20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB</sup></p></li>
<li><p>0x00000~0x9FFFF：主存储器。可读可写</p></li>
<li><p>0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写</p></li>
<li><p>0xC0000~0xFFFFF：存储各种硬件\系统信息。只读</p></li>
</ul>

<h3 id="toc_2">数据的宽度</h3>

<p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p>

<pre><code class="language-objc">#import &lt;UIKit/UIKit.h&gt;
#import &quot;AppDelegate.h&quot;

int test(){
    int cTemp = 0x1FFFFFFFF;
    return cTemp;
}

int main(int argc, char * argv[]) {
    printf(&quot;%x\n&quot;,test());
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>

<h3 id="toc_3">寄存器</h3>

<p><strong>内部部件之间由总线连接</strong><br/>
<img src="media/15281826293684/15281920704878.jpg" alt=""/></p>

<ul>
<li>可以通过寄存器找到对应的数据，对项目的调试、追踪是很重要的</li>
<li>不同的CPU，寄存器的个数、结构是不相同的</li>
</ul>

<h3 id="toc_4">通用寄存器</h3>

<ul>
<li><p>ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）</p>

<ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!
<img src="media/15281826293684/15281933267797.jpg" alt=""/></li>
</ul></li>
<li><p>通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算</p></li>
<li><p>也就是说寄存器只负责存东西，至于计算交给CPU</p></li>
</ul>

<h3 id="toc_5">pc寄存器(program counter)</h3>

<p><img src="media/15281826293684/15281935199483.jpg" alt=""/></p>

<ul>
<li>为指令指针寄存器，它指示了CPU当前要读取指令的地址</li>
<li>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</li>
<li>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义

<ul>
<li>比如 1110 0000 0000 0011 0000 1000 1010 1010 </li>
<li>可以当做数据   0xE003008AA </li>
<li>也可以当做指令  mov    x0, x8</li>
</ul></li>
<li>CPU根据什么将内存中的信息看做指令？

<ul>
<li>CPU将pc指向的内存单元的内容看做指令</li>
<li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li>
</ul></li>
</ul>

<p><img src="media/15281826293684/482DD597-1D2D-4828-A431-4EF46DAAD3F0.png" alt="482DD597-1D2D-4828-A431-4EF46DAAD3F0"/></p>

<p><img src="media/15281826293684/6046E81D-CE1A-479C-A2A9-11596D9781F0.png" alt="6046E81D-CE1A-479C-A2A9-11596D9781F0"/></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-05T10:33:04+08:00" itemprop="datePublished">2018/6/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15281659843189.html" itemprop="url">
		线程和多线程理论</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">1.线程和多线程定义</h3>

<blockquote>
<p>线程是程序中一个单一的顺序控制流程。进程内有一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指令运行时的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p>
</blockquote>

<h3 id="toc_1">2.线程和进程的区别</h3>

<blockquote>
<p>1.进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。<br/>
2.进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。<br/>
3.与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。<br/>
4.线程是进程中的一个单元，他是不能独立运行的，他必须依赖某个进程。</p>
</blockquote>

<h3 id="toc_2">3.使用多线程的原因</h3>

<blockquote>
<p>·使用线程可以把占据时间长的程序中的任务放到后台去处理<br/>
·用户界面的更新和交互是不能被阻塞的，耗时操作是不能放在主线程的<br/>
·当CPU是多核的时候，不同的进程可以实现并行，这样就提高了程序的运行效率<br/>
·有些任务并不是连续的，需要等待，比如网络收发数据、用户输入等, 这些操作并不需要等到执行完成，二是需要有变化才操作。</p>
</blockquote>

<h4 id="toc_3">4 多线程使用注意事项</h4>

<p>4.1 开辟过多线程的问题</p>

<blockquote>
<p>·系统需要为线程开辟存储空间来管理他，线程过多，会占用大量内存。<br/>
·线程是通过CPU来调度的，过多的线程会加大CPU的负担，会增加耗电量，还会让机器发烫。</p>
</blockquote>

<p>4.2 其他问题</p>

<blockquote>
<p>·多个线程同时访问同一数据的访问，要确保数据的安全<br/>
·线程死锁</p>
</blockquote>

<h4 id="toc_4">iOS 里的多线程</h4>

<blockquote>
<p>· NSThread 可以直接操作线程<br/>
· GCD: Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。<br/>
· NSOperation 在GCD之上的封装，更适合添加操作之间的依赖关系。</p>
</blockquote>

<p>注：如果有不准确的地方，欢迎大家来吐槽。QQ：1392984568 一米阳光 （iOS 修炼者 ）</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-03T19:35:52+08:00" itemprop="datePublished">2018/6/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%A7%84%E5%88%92.html'>第三方框架</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15280257520553.html" itemprop="url">
		pods 私有库</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">创建本地私有库</h3>

<ol>
<li>pod lib create QKEasyTest
<img src="media/15280257520553/15280808189626.jpg" alt=""/></li>
</ol>

<p>2.配置QKEasyTest git版本管理</p>

<pre><code>cd QKEasyTest
git init
git add . 
git commit -m &quot;first commit&quot; -a
git remote add origin https://gitee.com/yanzhi11/QKEasyTest.git
git push -u origin master
</code></pre>

<p><img src="media/15280257520553/15280818329296.jpg" alt=""/></p>

<p>3.添加你需要的私有库文件<br/>
<img src="media/15280257520553/15280844687860.jpg" alt=""/></p>

<p>4.修改QKEasyTest.podspec 文件 配置源码地址 <br/>
<img src="media/15280257520553/15280849737738.jpg" alt=""/></p>

<p>5.将修改提交到远程仓库，并打一个tag<br/>
<img src="media/15280257520553/15280910601610.jpg" alt=""/><br/>
6.讲QKEasyTest 添加到本地的索引库<br/>
<img src="media/15280257520553/15281026975863.jpg" alt=""/><br/>
然后推到自己的私有库</p>

<p>7.测试一下<br/>
<img src="media/15280257520553/15281028048076.jpg" alt=""/></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-03T13:45:58+08:00" itemprop="datePublished">2018/6/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%A7%84%E5%88%92.html'>第三方框架</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15280047582749.html" itemprop="url">
		轮播图</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">实现思路</h3>

<p>1.1: 三个视图，中间的视图用于显示当前播放的图片，左右的视图用于向左向右切换。</p>

<p>1.2: 无限循环的数学思路，以五张图片为例，<code>1</code> &lt;-&gt; <code>2</code> &lt;-&gt; <code>3</code> &lt;-&gt; <code>4</code> &lt;-&gt; <code>5</code> &lt;-&gt; <code>1</code> ... &lt;-&gt;<code>5</code>, 也就是第一张图片向左可以切换到最后一张图片，最后一张图片向右可以切换到第一张图片，然后中间的图片是连续的。我们设有总共有M张图片，那么很容易得到数列 <code>{Sn = (Sn-1 + 1) % M ， S1 = 1，S2 = 2}</code>  也就是说中间的图片是左边的图片 + 1 然后对总图片数取余。</p>

<p>1.3: 一个切换过程的细节，我们以播放下一张为例，当中间的视图被右边的视图切换掉后，此时显示的是过渡视图，我们将左边和中间视图的显示内容向又移动一个单元，也就是说中间的视图和右边的过渡视图此时是一样的，然后改变滚动视图的显示区域，把视图滚动到中间，也就是中间的视图在此霸占了显示区域，重新记录一下我们显示到了第几张图片，以便下次我们切换图片。这样就完成了一个切换，向左切换也是同理。</p>

<h3 id="toc_1">下面是iOS 的实现细节</h3>

<p><img src="media/15280047582749/15280105400096.jpg" alt=""/><br/>
1.主题部分：<br/>
 1.1: bodyView 承载三个 UIImageView, centerImageView 是当前展示的内容，leftImageView和rightImageView负责左右切换的时候显示,切换完成后要还原到centerImageView， 也就以centerImageView 为中心。<br/>
 1.2: page 记录当前滑动到了第几张了，每一次滑动，都会切换三张图片。如刚开始是 <code>1,2,3</code> 向右一个单元后图片变成了 <code>2,3,4</code>,这个page 在每次切换前后都会是起到参考的作用。<br/>
 1.3: imgesCount 图片的总张数， loopSpace: 轮播图的播放间隔，timer 用于自动播放。</p>

<pre><code>@interface QKLoopBanner () &lt;UIScrollViewDelegate&gt;

@property (nonatomic,strong) UIScrollView *bodyView;
@property (nonatomic,strong) UIImageView *leftImageView;
@property (nonatomic,strong) UIImageView *centerImageView;
@property (nonatomic,strong) UIImageView *rightImageView;
@property (nonatomic,strong) UIPageControl *pageControl;

@property (nonatomic,assign) NSUInteger page;
@property (nonatomic,assign) NSUInteger imgesCount;
@property (nonatomic,assign)NSTimeInterval loopSpace;

@property (nonatomic,strong)NSTimer *timer;
@end
</code></pre>

<p>2 播放器和其他类的交互<br/>
2.1: 统一采用代理设计模式，图片点击放在QKLoopBannerDelegate中，点击图片后，会把当前的轮播图（考虑到一个地方可能会有几个轮播图）、当前的显示视图、第几张图片的序号</p>

<pre><code>@class QKLoopBanner;

@protocol QKLoopBannerDelegate &lt;NSObject&gt;

@optional
- (void)loopBanner:(QKLoopBanner *)loopBanner
   didSelectedItem:(UIImageView *)imageView
             index:(NSUInteger)index;

@end
</code></pre>

<p>2.2 轮播图数据源方法<br/>
1. 获取轮播图的总张数<br/>
2. loopBanner:reloadImageView:index 刷新第index张图片，一般会连着调用三次，由于一次轮播。<br/>
3. pageControlOfloopBanner 自定义轮播指示器，如果不想要指示器返回nil就好。<br/>
4. chanedPage 实时报告当前的位置</p>

<pre><code>@protocol QKLoopBannerDataSource &lt;NSObject&gt;

@required
- (NSUInteger)numberOfImagesInLoopBanner:(QKLoopBanner *)loopBanner;
- (void)loopBanner:(QKLoopBanner *)loopBanner
   reloadImageView:(UIImageView *)imageView
             index:(NSUInteger)index;

@optional
- (void)loopBanner:(QKLoopBanner *)loopBanner
        chanedPage:(NSUInteger)page;
- (UIPageControl *)pageControlOfloopBanner:(QKLoopBanner *)loopBanner;

@end
</code></pre>

<p>3 轮播图开放的API<br/>
3.1 initWithFrame:loopSpace 初始化，loopSpace 自动播放时间间隔<br/>
3.2 delegate 交互代理，dataSource 轮播图数据源，数据源必须实现，不然是空白的。<br/>
3.3 reloadData : 当改变了轮播图的张数或者轮播图的具体内容，需要reloadData 重载一下数据。</p>

<pre><code>@interface QKLoopBanner : UIView

- (instancetype)initWithFrame:(CGRect)frame
                    loopSpace:(NSTimeInterval )loopSpace;
- (void)reloadData;


@property (nonatomic,assign) id &lt;QKLoopBannerDelegate&gt; delegate;
@property (nonatomic,assign) id &lt;QKLoopBannerDataSource&gt; dataSource;

@end
</code></pre>

<p>4 实现的具体细节</p>

<pre><code>4.1 通过 dataSource 获取图片张数
- (void)setDataSource:(id&lt;QKLoopBannerDataSource&gt;)dataSource {
    
    _dataSource = dataSource;
    if (_dataSource) {
        self.imgesCount = [dataSource numberOfImagesInLoopBanner:self];
    }
    
}
</code></pre>

<pre><code>4.2 处理 0,1, &gt;1 张的图片
- (void)setImgesCount:(NSUInteger)imgesCount {
    _imgesCount = imgesCount;
    _page = 0;
    switch (imgesCount) {
        case 0:
        {
            //没有图片的情况下，清空所有，不可交互
            [self.leftImageView setImage:nil];
            [self.centerImageView setImage:nil];
            [self.rightImageView setImage:nil];
            [self.bodyView setScrollEnabled:NO];
            [self.centerImageView setUserInteractionEnabled:NO];
            if (self.pageControl) {
                [self.pageControl removeFromSuperview];
                self.pageControl = nil;
            }
        }
            break;
        case 1:
        {
            //只有一张图片的情况下，让中间的视图显示图片，没有自动播放，不可滚动，但是可以点击
            [self.centerImageView setImage:nil];
            [self.rightImageView setImage:nil];
            [self changeToCenter];
            [self.dataSource loopBanner:self
                        reloadImageView:self.centerImageView
                                  index:0];
            [self.centerImageView setUserInteractionEnabled:YES];
            [self.bodyView setScrollEnabled:NO];
            if (self.pageControl) {
                [self.pageControl removeFromSuperview];
                self.pageControl = nil;
            }
        }
            break;
            
        default:
        {
            // 多余一张图片的时候，让中间的显示第一张
            // 让左边的显示最后一张，右边的显示下一张
            // bodyView的视野是中间的那个
            // 播放间隔后自动到下一张
            [self.bodyView setScrollEnabled:YES];
            [self.dataSource loopBanner:self
                        reloadImageView:self.rightImageView
                                  index:imgesCount-1];
            [self.dataSource loopBanner:self
                        reloadImageView:self.centerImageView
                                  index:0];
            [self.dataSource loopBanner:self
                        reloadImageView:self.rightImageView
                                  index:1];
            if ([self.dataSource respondsToSelector:@selector(loopBanner:chanedPage:)]) {
                [self.dataSource loopBanner:self chanedPage:_page];
            }
            [self.centerImageView setUserInteractionEnabled:YES];
            [self.timer setFireDate:[NSDate dateWithTimeIntervalSinceNow:self.loopSpace]];
            if ([self.dataSource respondsToSelector:@selector(pageControlOfloopBanner:)]) {
                self.pageControl = [self.dataSource pageControlOfloopBanner:self];
                [self addSubview:self.pageControl];
                [self.pageControl setNumberOfPages:imgesCount];
            }
        }
            break;
    }
}


</code></pre>

<pre><code>4.3 观察bodyView滚动的位置，当到左边或者右边的时候需要处理
- (void)addObservers {
    [self.bodyView addObserver:self
                    forKeyPath:@&quot;contentOffset&quot;
                       options:NSKeyValueObservingOptionNew
                       context:nil];
}


- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary&lt;NSString *,id&gt; *)change
                       context:(void *)context {
    if ([keyPath isEqualToString:@&quot;contentOffset&quot;]) {
        [self caculatePage];
    }
}

</code></pre>

<p>很关键的点，图片切换前夜 —— 位置计算<br/>
1. criticalValue 为一个很小的正数，这个点子很微妙，说出来就没有韵味了，留给大家慢慢体会。O(∩_∩)O哈哈~<br/>
2. X 坐标 &gt; 2 * CGRectGetWidth(self.bodyView.bounds) 说明是 从中间跑到了 右边， 所以是播放下一张<br/>
3. X 坐标是一个很小的正数，说明已经到第一张了</p>

<pre><code>- (void)caculatePage {
    if (self.imgesCount &gt; 0) {
        CGFloat pointX = self.bodyView.contentOffset.x;
        
        // judge critical value，first and third imageView&#39;s contentoffset
        // last to first or first to last
        CGFloat criticalValue = .2f;
        
     
        if (pointX &gt; 2 * CGRectGetWidth(self.bodyView.bounds) - criticalValue) {
            //centerImage to rightImage(next page)
            // {An | Sn = 1,2,3...n} == {An | Sn = n}
            // {Bn | Sn = 2,3,..n,1} == {Bn | Sn = (n + 1)%n }
            self.page = (self.page + 1) % self.imgesCount;
        } else if (pointX &lt; criticalValue) {
            //scroll to leftImage(previous page)
            // + self.imgesCount mod case for self.page == 0
            self.page = (self.page + self.imgesCount - 1) % self.imgesCount;
        }
    }
}
</code></pre>

<p>图片切换进行时<br/>
1.通过page，刷新左中右视图的显示<br/>
2.把中间的那个视图继续变到中间</p>

<pre><code>- (void)setPage:(NSUInteger)page {
    _page = page;
    NSUInteger leftIndex = (_page + self.imgesCount - 1) % self.imgesCount;
    NSUInteger rightIndex= (_page + 1) % self.imgesCount;
    [self.dataSource loopBanner:self
                reloadImageView:self.leftImageView
                          index:leftIndex];
    [self.dataSource loopBanner:self
                reloadImageView:self.centerImageView
                          index:_page];
    [self.dataSource loopBanner:self
                reloadImageView:self.rightImageView
                          index:rightIndex];
    if ([self.dataSource respondsToSelector:@selector(loopBanner:chanedPage:)]) {
        [self.dataSource loopBanner:self chanedPage:_page];
    }
    [self changeToCenter];
    [self.pageControl setCurrentPage:_page];
}
</code></pre>

<p>自动播放核心<br/>
1.如果中间的视图不在bodyView的视野，先调过来。<br/>
2.从中间位置切换到右边</p>

<pre><code> CGFloat criticalValue = .2f;
    if (self.bodyView.contentOffset.x &lt; CGRectGetWidth(self.bodyView.bounds) - criticalValue || self.bodyView.contentOffset.x &gt; CGRectGetWidth(self.bodyView.bounds) + criticalValue) {
        [self changeToCenter];
    }
    CGPoint newOffset = CGPointMake(self.bodyView.contentOffset.x + CGRectGetWidth(self.bodyView.bounds), self.bodyView.contentOffset.y);
    [self.bodyView setContentOffset:newOffset animated:YES];
</code></pre>

<p>最后，使用到了NSTimer，在轮播图需要释放前，需要先暂停timer，不然会造成内存泄露，切记，在 dealoc 里边是释放不了timer的。内存相关代码如下。</p>

<pre><code>- (void)removeFromSuperview {
    if (self.timer) {
        [self.timer invalidate];
        self.timer = nil;
    }
}
- (void)dealloc {
    [self removeObservers];
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-22T08:35:21+08:00" itemprop="datePublished">2018/5/22</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15269493216963.html" itemprop="url">
		iOS 开发与汇编语言</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><img src="media/15269493216963/15281815572621.jpg" alt=""/></p>

<blockquote>
<ul>
<li> <strong>汇编语言</strong>与<strong>机器语言</strong>一一对应，每一条机器指令都有与之对应的汇编指令</li>
<li> <strong>汇编语言</strong>可以通过编译得到<strong>机器语言</strong>，<strong>机器语言</strong>可以通过反汇编得到<strong>汇编语言</strong></li>
<li> 汇编还原成C的难度要大于C还原成OC</li>
</ul>
</blockquote>

<p>学习汇编的目的 </p>

<blockquote>
<p>·更深入的了解iOS app 运行的过程<br/>
·可以反汇编应用<br/>
·知道反汇编的过程后，会更清晰的认识到应用安全的紧迫性，会采取相应的防护措施<br/>
·为编写高效代码打下基础<br/>
·弄清代码的本质,看系统API的实现过程</p>
</blockquote>

<h3 id="toc_0">机器语言</h3>

<blockquote>
<p>由0和1组成的机器指令.<br/>
* 加：0100 0000<br/>
* 减：0100 1000<br/>
* 乘：1111 0111 1110 0000 <br/>
* 除：1111 0111 1111 0000 </p>
</blockquote>

<h3 id="toc_1">汇编语言(assembly language)</h3>

<blockquote>
<p>使用助记符代替机器语言<br/>
如:<br/>
* 加：INC EAX     通过编译器 0100 0000<br/>
* 减：DEC EAX     通过编译器 0100 1000<br/>
* 乘：MUL EAX         通过编译器 1111 0111 1110 0000<br/>
* 除：DIV EAX     通过编译器 1111 0111 1111 0000</p>
</blockquote>

<h3 id="toc_2">汇编语言的特点</h3>

<blockquote>
<p>*可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能<br/>
* 能够不受编译器的限制，对生成的二进制代码进行完全的控制<br/>
* 目标代码简短，占用内存少，执行速度快<br/>
* 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性<br/>
* 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护<br/>
* 不区分大小写，比如mov和MOV是一样的</p>
</blockquote>

<h3 id="toc_3">汇编语言的种类</h3>

<blockquote>
<ul>
<li>目前讨论比较多的汇编语言有

<ul>
<li>8086汇编（8086处理器是16bit的CPU）</li>
<li>Win32汇编</li>
<li>Win64汇编</li>
<li>ARM汇编（嵌入式、Mac、iOS）</li>
<li>......</li>
</ul></li>
</ul>
</blockquote>

<ul>
<li>我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同.</li>
</ul>

<table>
<thead>
<tr>
<th>架构</th>
<th>设备</th>
</tr>
</thead>

<tbody>
<tr>
<td>armv6</td>
<td>iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td>arm64</td>
<td>iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后</td>
</tr>
</tbody>
</table>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-05T08:25:16+08:00" itemprop="datePublished">2018/5/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15254799163209.html" itemprop="url">
		002--函数本质</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">关于CPU的补充</h2>

<h4 id="toc_1">寄存器</h4>

<p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>

<blockquote>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
</blockquote>

<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>

<h4 id="toc_2">高速缓存</h4>

<p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>

<blockquote>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个<strong>高速缓存存储区域</strong>.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
</blockquote>

<h3 id="toc_3">寄存器的补充</h3>

<h4 id="toc_4">数据地址寄存器</h4>

<p>数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。<br/>
<strong>ARM64中</strong></p>

<ul>
<li>64位: X0-X30, XZR(零寄存器)</li>
<li>32位: W0-W30, WZR(零寄存器)</li>
</ul>

<blockquote>
<p>注意:<br/>
之前讲解8086汇编中有一种特殊的寄存器段寄存器:CS,DS,SS,ES四个寄存器来保存这些段的基地址,这个属于Intel架构CPU中.在ARM中并没有</p>
</blockquote>

<h4 id="toc_5">浮点和向量寄存器</h4>

<p>因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数</p>

<ul>
<li>浮点寄存器 64位: D0 - D31  32位: S0 - S31</li>
</ul>

<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>

<ul>
<li>向量寄存器 128位:V0-V31</li>
</ul>

<h2 id="toc_6">栈</h2>

<ul>
<li>栈：是一种具有特殊的访问方式的存储空间（后进先出， Last In Out Firt，LIFO）
<img src="media/15193997917344/15193998892055.jpg" alt=""/></li>
</ul>

<h3 id="toc_7">SP和FP寄存器</h3>

<ul>
<li>sp寄存器在任意时刻会保存我们栈顶的地址.</li>
<li><p>fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址!()</p>

<blockquote>
<p>注意:ARM64开始,取消32位的 LDM,STM,PUSH,POP指令! 取而代之的是ldr\ldp  str\stp<br/>
ARM64里面 对栈的操作是16字节对齐的!!</p>
</blockquote></li>
</ul>

<h3 id="toc_8">关于内存读写指令</h3>

<blockquote>
<p>注意:读/写 数据是都是往高地址读/写</p>
</blockquote>

<p><strong>str(store register)指令</strong></p>

<p>将数据从寄存器中读出来,存到内存中.</p>

<p><strong>ldr(load register)指令</strong></p>

<p>将数据从内存中读出来,存到寄存器中</p>

<p>此ldr 和 str 的变种ldp 和 stp 还可以操作2个寄存器.</p>

<h3 id="toc_9">堆栈操作练习</h3>

<p>使用32个字节空间作为这段程序的栈空间,然后利用栈将x0和x1的值进行交换.</p>

<pre><code>sub    sp, sp, #0x20    ;拉伸栈空间32个字节
stp    x0, x1, [sp, #0x10] ;sp往上加16个字节,存放x0 和 x1
ldp    x1, x0, [sp, #0x10] ;将sp偏移16个字节的值取出来,放入x1 和 x0
</code></pre>

<h2 id="toc_10">bl和ret指令</h2>

<h4 id="toc_11">bl标号</h4>

<ul>
<li>将下一条指令的地址放入lr(x30)寄存器</li>
<li>转到标号处执行指令</li>
</ul>

<h4 id="toc_12">ret</h4>

<ul>
<li>默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址!</li>
</ul>

<blockquote>
<p>ARM64平台的特色指令,它面向硬件做了优化处理的</p>
</blockquote>

<h4 id="toc_13">x30寄存器</h4>

<p>x30寄存器存放的是函数的返回地址.当ret指令执行时刻,会寻找x30寄存器保存的地址值!</p>

<blockquote>
<p>注意:在函数嵌套调用的时候.需要讲x30入栈!</p>
</blockquote>

<h2 id="toc_14">函数的参数和返回值</h2>

<p>ARM64下,<strong>函数的参数</strong>是存放在X0到X7(W0到W7)这8个寄存器里面的.如果超过8个参数,就会入栈.<br/>
<strong>函数的返回值</strong>是放在X0 寄存器里面的.</p>

<h2 id="toc_15">函数的局部变量</h2>

<p>函数的局部变量放在栈里面!</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>
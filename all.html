<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	
  	
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html"></a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-15T14:35:08+08:00" itemprop="datePublished">2018/6/15</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%B7%A5%E5%85%B7.html'>工具</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15290445087885.html" itemprop="url">
		《计算机文化基础》模拟题</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>一、填空题（每空1分，共30分） <br/>
1. 计算机硬件是由____<strong><em>、</em></strong>_<strong><em>、</em></strong>_<strong><em>、</em></strong>_<strong><em>和</em></strong>_<strong><em>五部分组成。<br/><br/>
2. （1011111）2=（      ）10=（      ）8=（      ）16<br/><br/>
3. 十进制的0.625转换成二进制为       。<br/><br/>
4. 存储器通常分为</em></strong>____ 和 ____<strong><em>。<br/><br/>
5. 计算机软件分为</em></strong>_<strong><em>和</em></strong>_<strong><em>。<br/><br/>
6. 计算机中通用的字符编码是</em></strong>_<strong><em>码。<br/><br/>
7. 用BASIC语言编写的程序要通过</em></strong>_<strong><em>翻译成机器语言程序后才能被计算机执行。<br/><br/>
8. 在Windows98系统中，对误删除的文件或文件夹，可以通过</em></strong>_<strong><em>恢复。<br/><br/>
9. 在Windows98的“资源管理器”窗口中，为了使具有系统和隐藏属性的文件或文件夹不显示出来，首先应进行的操作是选择</em></strong>___<strong><em>菜单中的“文件夹选项”命令。<br/><br/>
10. 在Word中，选择“编辑”菜单中的</em></strong>_<strong><em>和</em></strong>_<strong><em>命令，可以将一段文字从一处移到另一处。<br/><br/>
11. 在Excel工作表中，数值型数据的默认对齐格式是</em></strong>____ 。<br/><br/>
12. 在Excel中，当某单元中的数据被显示为充满整个单元的一串<q>#</q>时，说明____<strong><em>。<br/><br/>
13. 在Excel中，如果选定某一单元格，此单元格称为</em></strong>_<strong><em>，也就是当前正在使用的单元格。<br/><br/>
14. Excel提供“</em></strong>_<strong><em>”和“高级筛选”两种工作方式。<br/><br/>
15. 在Excel中，如果想把一个数字型地址、日期或数值以文本方式存储，只需在该值之前置一个</em></strong>_<strong><em>。<br/><br/>
16. 在PowerPoint中要观看所有的幻灯片，应选择</em></strong>_<strong><em>视图。<br/><br/>
17. Internet的通信协议是</em></strong>_<strong><em>。<br/><br/>
18. 利用</em></strong>_<strong><em>可以实现不同类型的计算机和不同操作系统之间的文件传输。<br/><br/>
19. 计算机网络按其分布范围的大小可分为</em></strong>_<strong><em>和</em></strong>_<strong><em>。<br/><br/>
20. 通信控制处理机在网络拓扑结构中被称为</em></strong>____。  </p>

<p>二、选择题（每题1分，共30分）<br/><br/>
1. 电子计算机主要是以【  】划分发展阶段的。<br/><br/>
A) 集成电路    B) 电子元件<br/><br/>
C) 电子管      D) 晶件管<br/><br/>
2. 第一台电子计算机诞生于【  】。<br/><br/>
A) 德国    B) 美国    C) 英国    D) 中国<br/><br/>
3. 为解决内存储器与CPU间速度不平衡问题，采用【  】技术。<br/><br/>
A) Cache    B) RAM    C) ROM    D) 外存<br/><br/>
4. 把高级语言编写的源程序转换成机器语言的目标程序的软件称为【  】。<br/><br/>
A) 汇编程序          B) 源程序<br/><br/>
C) 数据库应用系统    D) 编译程序<br/><br/>
5. 下面属于高级语言的是【  】。<br/><br/>
A) 汇编、C、PASCAL<br/><br/>
B) 汇编、FORTRAN、C<br/><br/>
C) BASIC、PASCAL、C<br/><br/>
D) BASIC、FORTRAN、机器语言<br/><br/>
6. 在微型计算机中，存储数据是以【  】。<br/><br/>
A) KB为单位     B) 位为单位<br/><br/>
C) 字长为单位    D) 字节为单位<br/><br/>
7. 与十进制数97等价的八进制数是【  】。<br/><br/>
A) 1100001    B) 141    C) 61    D) 111<br/><br/>
8. 在下列存储器中，访问速度最快的是【  】。<br/><br/>
A) 硬盘    B) 软盘    C) 内存    D) 磁带<br/><br/>
9. 在Windows98系统中，下列叙述正确的是【  】。<br/><br/>
A) 只能用鼠标<br/><br/>
B) 为每一个任务自动建立一个显示窗口，其位置和大小不能改变<br/><br/>
C) 在不同的磁盘间不能用鼠标拖动文件名的方法实现文件的移动<br/><br/>
D) Windows98打开的多个窗口，既可平铺，也可层叠<br/><br/>
10. Windows98系统正确关机的过程是【  】。<br/><br/>
A) 在运行Windows98时直接关机<br/><br/>
B) 关闭所有运行程序，选择<q>开始</q>按钮中<q>关闭系统</q>菜单，在弹出的对话框中选择<q>关闭计算机</q>项<br/><br/>
C) 先退到Dos系统，再下电关机<br/><br/>
D) 关闭所有任务栏的窗口后，直接下电关机<br/><br/>
11. 在Windows98系统时，如果鼠标指针变成<q>I</q>形状，则表明【  】。<br/><br/>
A) 当前系统正在访问磁盘<br/><br/>
B) 当前鼠标指针出现处可接收键盘输入的字符<br/><br/>
C) 是阻挡符号，指出鼠标指针出现处不能执行某种操作<br/><br/>
D) 可以移动<q>资源管理器</q>中的分隔条<br/><br/>
12. 在Windows98系统中，有关“回收站”的论述，正确的是【  】。<br/><br/>
A) “回收站”中的内容将被永久保留<br/><br/>
B) “回收站”不占用磁盘空间<br/><br/>
C) “回收站”中的内容可以删除<br/><br/>
D) “回收站”只能在桌面上找到<br/><br/>
13. 有关Windows98系统，以下说法正确的是【  】。<br/><br/>
A) 在所有微机上都可以使用<br/><br/>
B) Windows98是图形化的界面<br/><br/>
C) Windows98不能同时运行多个应用程序，但可以打开多个编辑文本窗口<br/><br/>
D) 必须退出Windows98系统，才可切换到Dos方式<br/><br/>
14. 在Windows98系统中，当应用程序窗口最小化以后，再次打开此应用程序窗口，可以通过【  】。<br/><br/>
A) 双击应用程序图标      B) 文件菜单的运行命令<br/><br/>
C) 单击最小化后的图标    D) 单击桌面的任何地方<br/><br/>
15. Office2000组件中用于创建、编制和发布网页的是【  】。<br/><br/>
A) Word2000        B) Excel2000<br/><br/>
C) FrontPage2000    D) Outlook2000<br/><br/>
16. 在Word主窗口的右上角、可以同时显示的按钮是【  】。<br/><br/>
A) 最小化、还原和最大化<br/><br/>
B) 还原、最大化和关闭<br/><br/>
C) 还原和最大化<br/><br/>
D) 最小化、还原和关闭<br/><br/>
17. 下面对Word编辑功能的描述中错误的是【  】。<br/><br/>
A) Word可以开启多个文档编辑窗口<br/><br/>
B) Word可以插入多种类型的图型文件<br/><br/>
C) Word可以将多种格式的系统日期、时间插入到光标位置<br/><br/>
D) 使用<q>编辑</q>菜单中的<q>复制</q>命令可将已选中的对象拷贝到光标位置<br/><br/>
18. 在Word中，如果要在一个表格中一次插入5行，正确的操作选择是【  】。<br/><br/>
A) 选择“表格”菜单中的“插入行”命令<br/><br/>
B) 把插入点放在行尾部，连按5次回车键<br/><br/>
C) 在“插入”菜单中选择“行数”命令<br/><br/>
D) 选定5行，选择“表格”菜单中的“插入行”命令<br/><br/>
19. 有关Word的陈述中，错误的选择是【  】。<br/><br/>
A) 能创建Web页    B) 能放映幻灯片<br/><br/>
C) 能制作图形     D) 能创建表格<br/><br/>
20. 在Excel中，在不同的单元格输入下面内容，其中被Excel识别为字符型数据的是【  】。<br/><br/>
A) 2000-11-14    B) ￥100    C) 46%    D) 北京<br/><br/>
21. 在Excel中，在单元格中输入公式时，输入的第一个符号是【  】。<br/><br/>
A) =    B) +    C) -    D) \(  <br/>
22. 在Excel工作表中，将C1单元中的公式“=A\)1”复制到D2单元后，D2单元中的值将与【  】单元中的值相等。<br/><br/>
A) B2    B) A2    C) A1    D) B1<br/><br/>
23. 在Excel中，对一含标题行的工作表进行排序，当在“排序”对话框中的“当前数据清单”框中选择“没有标题行”选项按钮时，该标题行【  】。<br/><br/>
A) 将参加排序        B) 将不参加排序<br/><br/>
C) 位置总在第一行    D) 位置总在倒数第一行<br/><br/>
24. 在Excel中，计算工作表B1~B6数值的总和，使用的函数是【  】。<br/><br/>
A) SUM（B1：B6）    B) AVE（B1：B6）<br/><br/>
C) MIN（B1：B6）    D) COUNT（B1：B6）<br/><br/>
25. 在PowerPoint中，对于“模板”的描述正确的是【  】。<br/><br/>
A) 一旦选择了某种“模板”，整个幻灯片都自动采用该“模板”的设计方案<br/><br/>
B) 每一张幻灯片的模板可以不同<br/><br/>
C) 在制作幻灯片时，“模板”一旦选择，就不能改变<br/><br/>
D) “模板”的配色是不可以改变的<br/><br/>
26. 在电子邮件中所包含的信息【  】。<br/><br/>
A) 只能是文字    B) 只能是文字与图形图象信息<br/><br/>
C) 只能是文字与声音信息<br/><br/>
D) 可以是文字、声音和图形图像信息<br/><br/>
27. WWW中的超文本指的是【  】。<br/><br/>
A) 包含图片的文本<br/><br/>
B) 包含多种文本的文本<br/><br/>
C) 包含链接的文本<br/><br/>
D) 包含动画的文本<br/><br/>
28. 在常见领域的域名中，其为教育机构用途的域名是【  】。<br/><br/>
A) COM    B) NET    C) EDU    D) ORG<br/><br/>
29. 局域网常用的拓扑结构一般不包括【  】。<br/><br/>
A) 总线形    B) 环形    C) 网状形    D) 星形<br/><br/>
30. 下列结构中不是计算机网络的系统结构的是【  】。<br/><br/>
A) 星型结构    B) 总线结构<br/><br/>
C) 单线结构    D) 环型结构  </p>

<p>三、简答题（每题4分，共16分）<br/><br/>
1. 计算机的发展经历了哪几个阶段？各阶段使用何种电子逻辑器件？  </p>

<ol>
<li><p>试述计算机硬件的组成？  </p></li>
<li><p>“复制”与“剪切”有何区别？  </p></li>
<li><p>什么是计算机网络？Internet的中文名称是什么，它的主要用途？  </p></li>
</ol>

<p>四、综合操作（每题12分，共24分）<br/><br/>
1. 资源管理器的使用。<br/><br/>
（1）启动资源管理器，显示D盘内容；<br/><br/>
（2）以“详细资料”方式显示文件和文件夹；<br/><br/>
（3）对文件和文件夹按名称排列；<br/><br/>
（4）在D盘根下建立“我的练习”文件夹；<br/><br/>
（5）将“我的练习”文件夹名改为“临时文件”。 </p>

<ol>
<li>利用Excel，按如下表格和要求建立学生档案表文档文件。<br/>
学生档案报表<br/>
学号 姓 名 出生日期 数学成绩 语文成绩 平均成绩<br/>
980001 赵卫红 95-1-3 95 90<br/>
980005 李易雨 94-11-6 92 89<br/>
980003 包中虎 96-4-5 76 93<br/>
980002 汪 韦 94-10-10 88 91<br/>
980004 蒋 茁 95-6-8 90 94<br/>
（1）输入表格数据；<br/>
（2）计算每个学生的平均成绩；<br/>
（3）按平均成绩以升序重新排列学生档案表；<br/>
（4）建立学生档案表曲线图并将其保存在同一个工作表中（曲线图图形自定）；<br/>
（5）将表以cjb文件名保存在d:/temp文件夹中。<br/></li>
</ol>

<p>参考答案<br/><br/>
一、填空题（每空1分，共30分）<br/><br/>
1. 运算器    控制器    存储器    输入设备    输出设备<br/><br/>
2. 95    137    5F<br/><br/>
3. 0.101<br/><br/>
4. 内存    外存<br/><br/>
5. 系统软件    应用软件<br/><br/>
6. ASC II<br/><br/>
7. 解释程序<br/><br/>
8. 回收站<br/><br/>
9. 查看<br/><br/>
10. 剪切    粘贴<br/><br/>
11. 右对齐<br/><br/>
12. 数据长度超过单元格宽度<br/><br/>
13. 活动单元格<br/><br/>
14. 自动筛选<br/><br/>
15. 单引号<br/><br/>
16. 幻灯片<br/><br/>
17. TCP/IP<br/><br/>
18. 文件传输FTP<br/><br/>
19. 局域网、广域网<br/><br/>
20. 网络节点<br/><br/>
二、选择题（每题1分，共30分）<br/><br/>
1. B      2. B     3. A     4. D     5. C<br/><br/>
6. D      7. B     8. C     9. D    10. B<br/><br/>
11. B    12. C    13. B    14. C    15. C<br/><br/>
16. D    17. D    18. D    19. B    20. D<br/><br/>
21. A    22. D    23. A    24. A    25. A<br/><br/>
26. D    27. C    28. C    29. C    30. C<br/><br/>
三、简答题（每题4分，共16分）<br/><br/>
1. 计算机主要经历了4代，第一代主要采用电子管，第二代采用晶体管，第三代采用集成电路，第四代采用大规模和超大规模集成电路作为元器件。<br/><br/>
2. 计算机硬件系统由运算器、控制器、存储器和输入设备、输出设备五部分组成。<br/><br/>
3. 复制是不删除所选定的数据，只把它放置到剪贴板上，而剪切是删除所选定的数据并将其放置到剪贴板上。<br/><br/>
4. 计算机网络是指以能够相互共享资源的方式互联起来的自治计算机系统的集合。Internet的中文名称是因特网或互联网，它的主要用途是电子邮件E-mail、文件传输FTP、远程登录Telnet、信息查询服务。<br/><br/>
四、模拟操作题（每题12分，共24分）<br/><br/>
1. 资源管理器的使用<br/><br/>
（1）单击“开始”按钮，选择“程序/Windows资源管理器”命令；<br/><br/>
（2）在左窗口中单击D盘图标；<br/><br/>
（3）选择“查看/详细资料”命令；<br/><br/>
（4）选择“查看/排列图标/按名称”命令；<br/><br/>
（5）单击“文件”菜单，将鼠标定位在“新建”菜单条上，从下级菜单中选择文件夹，在名称框中输入“我的练习”；<br/><br/>
（6）单击D盘图标，选择一个.DOC文件，单击“编辑菜单/复制”命令，选择text文件夹，单击“编辑菜单/粘贴”命令；<br/><br/>
（7）选中“我的练习”文件夹，单击鼠标右键，选择“重命名”命令，输入“临时文件”，单击回车键。<br/><br/>
2. 操作步骤<br/><br/>
（1）启动Excel进入文档编辑窗口；<br/><br/>
（2）按照给定数据输入各项信息；<br/><br/>
（3）单击B列标选择第一列，选择“格式/单元格”命令，选择“数字”标签，在“分类”列表项中选择“文本”项，单击“确定”按钮；<br/><br/>
（4）用步骤（2）的方法设置第一行为“文本格式”；<br/><br/>
（5）将鼠标的光标放置在F2中，输入“= AVERAGE（D2+E2）”，按回车键；<br/><br/>
（6）将鼠标的光标放置在F2单元格右下脚处的填充柄，按住鼠标左键向下拖动到F6；<br/><br/>
（7）将鼠标的光标放置在F列中，单击工具栏上升序排列按钮；<br/><br/>
（8）选定图表数据，单击“常用”工具栏上的“图表向导”按钮, 屏幕上出现“图表向导4-1”话框，在该对话框中选择曲线图，单击“下一步”按钮；  </p>

<p>（9）幕上出现“图表向导4-2”对数据区域及系列进行设置，单击“下一步”按钮；<br/><br/>
（10）屏幕上出现“图表向导4-3”对话框，可以键入图表标题“学生档案报表”，单击“下一步”按钮；<br/><br/>
（11）屏幕上出现“图表向导4-4”对话框，选中同一个工作表中，单击“下一步”按钮，单击“完成”按钮；<br/><br/>
（12）单击“文件/保存”命令打开“另存为”对话框，在“保存位置”中选择D盘temp文件夹，在文件名中输入cjb，单击“保存”按钮。  </p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-15T07:08:00+08:00" itemprop="datePublished">2018/6/15</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%A4%9A%E5%AA%92%E4%BD%93.html'>多媒体</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15290176801726.html" itemprop="url">
		GPUImage 极简使用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4 id="toc_0">单张图片处理</h4>

<p>1.单个滤镜</p>

<pre><code>//设置滤镜
[self.filter useNextFrameForImageCapture];
[self.filter forceProcessingAtSizeRespectingAspectRatio:self.image.size];
self.filter.brightness = 0.5;

// 传入要处理的图片
GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:self.image];
// 给图片添加滤镜
[picture addTarget:self.filter];

//渲染
[picture processImage];

//从滤镜中获取图片
[self.imageView setImage:self.filter.imageFromCurrentFramebuffer];
</code></pre>

<p>2.滤镜组</p>

<pre><code>//第一个滤镜
self.filter1 = [[GPUImageBrightnessFilter alloc] init];
self.filter1.brightness = 0.0;
    
//第二个滤镜
self.filter2 = [[GPUImageSaturationFilter alloc] init];
self.filter2.saturation = 1.0;
    
//滤镜组
self.groupFilter = [[GPUImageFilterGroup alloc] init];
[self.groupFilter addTarget:self.filter1];
[self.groupFilter addTarget:self.filter2];
[self.groupFilter forceProcessingAtSizeRespectingAspectRatio:self.image.size];
    
//滤镜间的依赖关系，一个滤镜处理好后再去处理下一个滤镜
[self.filter1 addTarget:self.filter2];
[self.groupFilter setInitialFilters:[NSArray arrayWithObject:self.filter1]];
[self.groupFilter setTerminalFilter:self.filter2];
    
//输入源
GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:self.image];
[picture addTarget:self.groupFilter];
   
 //处理图片并获取输出 
[self.groupFilter useNextFrameForImageCapture];
[picture processImage];
[self.imageView setImage:self.groupFilter.imageFromCurrentFramebuffer];
</code></pre>

<p>3.美颜相机</p>

<pre><code>//创建相机
self.Camera = [[GPUImageStillCamera alloc] initWithSessionPreset:AVCaptureSessionPreset640x480 cameraPosition:AVCaptureDevicePositionFront];
self.Camera.outputImageOrientation = UIInterfaceOrientationPortrait;

//创建滤镜
self.filter = [[GPUImageSaturationFilter alloc] init];
self.filter.saturation = 1.0;
    
//相机上添加滤镜    
[self.Camera addTarget:self.filter];
    
//图片处理后的输出展示
self.GPUImageView = [[GPUImageView alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT-64)];
[self.view addSubview:self.GPUImageView];

//输出结果要给显示
[self.filter addTarget:self.GPUImageView];

//开始捕获图像
[self.Camera startCameraCapture];

//拍照获取的图片
 [self.Camera capturePhotoAsJPEGProcessedUpToFilter:self.filter withCompletionHandler:^(NSData *processedJPEG, NSError *error) {
        
  
        
    }];
</code></pre>

<p>4.视屏录制</p>

<blockquote>
<p>初始化设置<br/>
initWithMovieURL:size 视屏保存的地址和视频的大小<br/>
startRecording 开始录制<br/>
[filter addTarget:self.movieWriter] 添滤镜<br/>
[self.movieWriter startRecording] 开始录制<br/>
[self.videoCamera pauseCameraCapture]; 暂停<br/>
[self.videoCamera resumeCameraCapture]; 恢复</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-14T18:00:12+08:00" itemprop="datePublished">2018/6/14</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%A4%9A%E5%AA%92%E4%BD%93.html'>多媒体</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15289704128303.html" itemprop="url">
		GPUImage 初探</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li>功能</li>
</ol>

<blockquote>
<p>1.imgage的PS工具，具有丰富的滤镜和特效<br/>
2.美颜相机：实时处理摄像头返回的图片数据<br/>
3.视频滤镜、美颜</p>
</blockquote>

<p>2.优点</p>

<blockquote>
<p>1.最低可支持 iOS 4.0<br/>
2.使用了GPU，可充分利用苹果手机的硬件，响应速度快。<br/>
3.底层是对OpenGL的封装，可降低开发难度<br/>
4.内置两百多种滤镜，还可自定义滤镜，实用性和扩展性强</p>
</blockquote>

<p>3.GPUImage 使用的大致流程</p>

<blockquote>
<p>1.image -&gt; GPUImageOutput, 将外部待处理图片传入到 GPUImageOutput 等待处理<br/>
2.创建所需要的滤镜，通过 GPUImageOutput 的 addTarget 去实现滤镜，滤镜可以叠加。<br/>
3.通过GPUImageInput 获得处理后的结果</p>
</blockquote>

<p>4.GPUImage 使用的框架</p>

<blockquote>
<p>1.AVFoundation 拍照和视频录制<br/>
2.CoreMedia 音视频的时间管理<br/>
3.CoreVideo 视频处理<br/>
4.OpenGLES 图像处理，GPUImage的核心<br/>
5.QuarzCore 核心动画（需要看在哪用了）</p>
</blockquote>

<p>5.GPUImage 板块</p>

<blockquote>
<p>1.图片的输入: GPUImageOutput、GPUImageVideoCamera、GPUImageStillCamera、GPUImagePicture、GPUImageMovie、GPUImageMovieComposition、GPUImageTextureInput、GPUImageRawDataInput、GPUImageUIElement、GPUImageColorConversion<br/>
2.处理后的图片/输出:GPUImageView、GPUImageMovieWriter、GPUImageTextureOutput、GPUImageRawDataOutput<br/>
3.核心 —— 滤镜: 色彩、图像处理、混合、特效</p>
</blockquote>

<p>6.GPUImage 滤镜的基础类</p>

<blockquote>
<p>GPUImageFilter //所有Filter父类<br/>
    GPUImageTwoInputFilter<br/>
    GPUImageThreeInputFilter<br/>
    GPUImageFourInputFilter<br/>
    GPUImageTwoPassFilter<br/>
    GPUImageTwoPassTextureSamplingFilter<br/>
    GPUImageFilterGroup<br/>
    GPUImage3x3TextureSamplingFilter<br/>
    GPUImageTwoInputCrossTextureSamplingFilter<br/>
    GPUImageBuffer</p>
</blockquote>

<p>7.项目常用滤镜 —— 颜色滤镜说明</p>

<blockquote>
<p>GPUImageBrightnessFilter 亮度滤镜<br/>
    GPUImageLevelsFilter 层次过滤器<br/>
    GPUImageExposureFilter 曝光滤镜<br/>
    GPUImageContrastFilter 对比度滤镜<br/>
    GPUImageSaturationFilter 饱和度滤镜<br/>
    GPUImageGammaFilter Gamma滤镜<br/>
    GPUImageColorMatrixFilter 彩色矩阵滤镜<br/>
    GPUImageRGBFilter RGB滤镜<br/>
    GPUImageHSBFilter HSB(噪点)滤镜<br/>
    GPUImageHueFilter Hue色调滤镜<br/>
    GPUImageMonochromeFilter 单色滤镜<br/>
    GPUImageFalseColorFilter 伪彩色滤镜<br/>
    GPUImageHazeFilter 迷雾滤镜<br/>
    GPUImageSepiaFilter 深褐色滤镜<br/>
    GPUImageColorInvertFilter 彩色反转滤镜<br/>
    GPUImageGrayscaleFilter 灰度滤镜<br/>
    GPUImageLuminanceThresholdFilter 亮度阈值滤镜<br/>
    GPUImageAdaptiveThresholdFilter 自适应阈值滤镜<br/>
    GPUImageSolarizeFilter 曝光滤镜<br/>
    GPUImageAverageLuminanceThresholdFilter 平均亮度阈值滤镜<br/>
    GPUImageHistogramFilter     直方图滤镜<br/>
    GPUImageHistogramGenerator 特殊直方图滤镜<br/>
    GPUImageHistogramEqualizationFilter 直方图均衡化滤波器<br/>
    GPUImageToneCurveFilter 色调曲线滤波器<br/>
    GPUImageHighlightShadowFilter 高光阴影滤镜<br/>
    GPUImageLookupFilter 查找滤波器<br/>
    GPUImageAmatorkaFilter 阿普特卡滤波器<br/>
    GPUImageSoftEleganceFilter 基于查找的颜色重映射过滤器<br/>
    GPUImageOpacityFilter 调整传入图像的Alpha通道<br/>
    GPUImageAverageColor 图像中每个像素的RGBA分量进行平<br/>
    GPUImageLuminosity 图像缩小到其平均亮度<br/>
    GPUImageSolidColorGenerator 纯色滤镜<br/>
    GPUImageChromaKeyFilter 色度键滤波器<br/>
    GPUImageWhiteBalanceFilter 白平衡滤镜<br/>
    GPUImageLuminanceRangeFilter 亮度范围滤镜</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-13T09:54:13+08:00" itemprop="datePublished">2018/6/13</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='AppSafe.html'>AppSafe</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15288548488435.html" itemprop="url">
		App安全与加密下</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">Hash （散列函数）</h3>

<p>1.Hash定义</p>

<blockquote>
<p>Hash:把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
</blockquote>

<p>2.哈希的特点</p>

<blockquote>
<p>1.同样的输入会有同样的哈希值。<br/>
2.同一个哈希值可以从不同的输入得到。<br/>
3.任意长度的输入得到的输出长度固定，也就是说这种算法是不可以逆的。</p>
</blockquote>

<p>3.哈希的用途</p>

<blockquote>
<ol>
<li>数字签名</li>
<li>文件比对，同一个文件的hash值是一样的，而且Hash值是很难重复的。</li>
<li>git 提交的版本对比号码</li>
<li>原文加密，比如用户的密码。在客户端和服务器直接使用加密后的密码，这样黑客很难得到用户的真实输入的密码。</li>
</ol>
</blockquote>

<p>4.常用的函数</p>

<pre><code>// data 需要加密的数据  len 加密数据的长度 md 加密后的结果

//MD5 
CC_MD5(const void *data, CC_LONG len, unsigned char *md)

// SHA1 
CC_SHA1(const void *data, CC_LONG len, unsigned char *md)

// SHA256
CC_SHA256(const void *data, CC_LONG len, unsigned char *md)
</code></pre>

<p>5.高级版的哈希算法 - HMAC</p>

<blockquote>
<p>HMAC是密钥相关的哈希运算消息认证码（HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。</p>
</blockquote>

<pre><code>// SHA512
CC_SHA512(const void *data, CC_LONG len, unsigned char *md)

// CCHmac 
/* algorithm 有：
    kCCHmacAlgSHA1,
    kCCHmacAlgMD5,
    kCCHmacAlgSHA256,
    kCCHmacAlgSHA384,
    kCCHmacAlgSHA512,
    kCCHmacAlgSHA224
*/
// key 加固数据
void CCHmac(
    CCHmacAlgorithm algorithm,  /* kCCHmacAlgSHA1, kCCHmacAlgMD5 */
    const void *key,
    size_t keyLength,           /* length of key in bytes */
    const void *data,
    size_t dataLength,          /* length of data in bytes */
}

</code></pre>

<p>6.终端生成Hash 值命令， 我们义字符串 “hello world” 为例</p>

<pre><code>md5 -s &quot;hello world&quot; //MD5
echo -n &quot;hello world&quot;&quot; | openssl sha -sha1 //SHA1
echo -n &quot;hello world&quot;&quot; | openssl sha -sha256 //SHA256
echo -n &quot;hello world&quot;&quot; | openssl sha -sha512 //SHA512
echo -n &quot;hello world&quot;&quot; | openssl dgst -md5 -hmac &quot;key&quot; //HMAC + MD5
echo -n &quot;hello world&quot;&quot; | openssl sha -sha1 -hmac &quot;key&quot; /HMAC + SHA1
echo -n &quot;hello world&quot;&quot; | openssl sha -sha256 -hmac &quot;key&quot; /HMAC + SHA256
echo -n &quot;hello world&quot;&quot; | openssl sha -sha512 -hmac &quot;key&quot; /HMAC + SHA512
</code></pre>

<h4 id="toc_1">Hash 破解与防范</h4>

<p>破解原理 </p>

<blockquote>
<ol>
<li>通过穷举字符组合的方式，创建了明文密文对应查询数据库。 这种破解的一般是密码，这种简单的字符串</li>
<li>获得签名的规则和加盐值，进行重签名，然后就可以更改参数的值</li>
</ol>
</blockquote>

<p>防范</p>

<blockquote>
<ol>
<li>对于密码的转化，可以使用更难穷举的HMAC</li>
<li>对于重签名，加盐的参数不放在客户端【客户端可逆向获取】</li>
<li>对于网络传输加盐值可以截取的问题，可以将这个设置一个时效性。</li>
<li>参数不要采用明文，可以使用一定的加密方式</li>
</ol>
</blockquote>

<h4 id="toc_2">对称加密</h4>

<p>常见的对称加密方式</p>

<blockquote>
<p>DES 3DES AES <q>高级</q>加密标准<br/>
   ECB 电子代码本,每个块都是独立加密的<br/>
   CBC 密码块链:使用一个密钥和一个初始化向量 (IV)对数据执行加密转换,可以有效地保证密文的完整性。</p>
</blockquote>

<p>重要的函数</p>

<pre><code> CCCryptorStatus CCCrypt(
    CCOperation op,         /* kCCEncrypt, etc. */
    CCAlgorithm alg,        /* kCCAlgorithmAES128, etc. */
    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */
    const void *key,
    size_t keyLength,
    const void *iv,         /* optional initialization vector */
    const void *dataIn,     /* optional per op and alg */
    size_t dataInLength,
    void *dataOut,          /* data RETURNED here */
    size_t dataOutAvailable,
    size_t *dataOutMoved)
enum {
    kCCModeECB      = 1,
    kCCModeCBC      = 2,
    kCCModeCFB      = 3,
    kCCModeCTR      = 4,
    kCCModeF8       = 5, // Unimplemented for now (not included)
    kCCModeLRW      = 6, // Unimplemented for now (not included)
    kCCModeOFB      = 7,
    kCCModeXTS      = 8,
    kCCModeRC4      = 9,
    kCCModeCFB8     = 10,
};
</code></pre>

<p>参数说明<br/>
1.CCOperation:  kCCEncrypt:加密， kCCDecrypt:解密</p>

<p>2.alg  加密解密方式  </p>

<pre><code>2.1 kCCAlgorithmAES128 = 0
2.2  kCCAlgorithmAES = 0
2.3  kCCAlgorithmDES,
2.4 kCCAlgorithm3DES,       
2.5 kCCAlgorithmCAST,       
2.6 kCCAlgorithmRC4,
2.7 kCCAlgorithmRC2,   
2.8 kCCAlgorithmBlowfish      
</code></pre>

<blockquote>
<p>3.options 加密选项 kCCOptionPKCS7Padding | kCCOptionECBMode  如果用了iv 就有 kCCOptionECBMode<br/>
4.key 加密解密的密钥<br/>
5.keyLength 加密的长度， 根据alg 类型取对应的长度<br/>
6.iv 初始化向量<br/>
7.dataIn 加密数据<br/>
8.dataInLength 加密数据的长度<br/>
9.dataOut 加密解密后的数据<br/>
10.dataOutAvailable dataOut的长度<br/>
11.dataOutMoved 数据最后的长度</p>
</blockquote>

<h4 id="toc_3">非对称加密</h4>

<p>重要函数</p>

<pre><code> SecKeyDecrypt(
SecKeyRef           key,                /* Private key */
SecPadding          padding,    /* kSecPaddingNone,kSecPaddingPKCS1, kSecPaddingOAEP */
const uint8_t       *cipherText,
size_t              cipherTextLen,/* length of cipherText */
uint8_t             *plainText,
size_t              *plainTextLen)
</code></pre>

<p>SecKeyDecrypt 使用公钥加密</p>

<blockquote>
<p>SecKeyRef 公钥<br/>
SecPadding <br/>
cipherText 加密的数据<br/>
cipherTextLen 加密数据的长度<br/>
plainText 结果数据<br/>
plainTextLen  数据结果的长度</p>
</blockquote>

<p>SecKeyDecrypt  使用私钥解密</p>

<pre><code>SecKeyDecrypt(
SecKeyRef           key,                /* Private key */
SecPadding          padding,/* kSecPaddingNone,   kSecPaddingPKCS1,kSecPaddingOAEP */
const uint8_t       *cipherText,
size_t              cipherTextLen,/* length of cipherText */
uint8_t             *plainText, 
size_t              *plainTextLen)
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-11T13:48:50+08:00" itemprop="datePublished">2018/6/11</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='AppSafe.html'>AppSafe</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15286961308804.html" itemprop="url">
		App全与加密上</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">加密算法分类</h3>

<blockquote>
<ul>
<li>对称加密:加密和解密都是使用一个密钥，密钥的保密工作就非常重要.</li>
<li>非对称加密:用公钥加密，私钥解密; 用私钥加密，公钥解密.</li>
</ul>
</blockquote>

<h4 id="toc_1">对称加密</h4>

<p>常见对称加密算法</p>

<blockquote>
<p>1.DES 数据加密标准<br/>
2. 3DES<br/>
3. AES <q>高级</q>加密标准<br/>
4. ECB 电子代码本,每个块都是独立加密的<br/>
5.CBC 密码块链:使用一个密钥和一个初始化向量 (IV)对数据执行加密转换,可以有效地保证密文的完整性。</p>
</blockquote>

<p>ECB 终端测试命令</p>

<pre><code>$ openssl enc -des-ecb -K 616263 -nosalt -in msg1.txt -out msg1.bin //加密
$ openssl enc -des-ecb -K 616263 -nosalt -in msg1.bin -out msg1.txt -d //解密
$ xxd msg1.bin // 查看加密之后的二进制文件
</code></pre>

<p>CBC终端测试命令</p>

<pre><code>$ openssl enc -des-cbc -K 616263 -iv 0000000000000000 -nosalt -in a.txt -out msg1.bin //加密
$ openssl enc -des-cbc -K 616263 -iv 0000000000000000 -nosalt -in msg1.bin -out msg4.txt -d //解密
$ xxd msg1.bin //查看加密之后的二进制文件
</code></pre>

<h5 id="toc_2">非对称加密算法</h5>

<p>概要</p>

<blockquote>
<p>1.加密解密方法： 用公钥解密然后用私钥解密；或者私钥加密然后用公钥解密<br/>
2.优缺点，优点是安全 缺点是速度慢</p>
</blockquote>

<p>RSA原理<br/>
<img src="media/15286961308804/15287963724258.jpg" alt=""/></p>

<p>OpenSSL 终端命令</p>

<pre><code>openssl genrsa -out private.pem 512 //生成强度是 512 的 RSA 私钥
openssl rsa -in private.pem -text -out private.txt //以明文输出私钥内容
openssl rsa -in private.pem -check //校验私钥文件
openssl rsa -in private.pem -out public.pem -outform PEM -pubout //从私钥中提取公钥
$ openssl rsa -in public.pem -out public.txt -pubin -pubout -text //以明文输出公钥内容
openssl rsautl -encrypt -pubin -inkey public.pem -in msg.txt -out msg.bin //使用公钥加密小文件
openssl rsautl -decrypt -inkey private.pem -in msg.bin -out a.txt //使用私钥解密小文件
openssl rsa -in private.pem -out private.der -outform der //将私钥转换成 DER 格式
openssl rsa -in public.pem -out public.der -pubin -outform der //将公钥转换成 DER 格式
</code></pre>

<p>iOS 相关证书生成命令</p>

<pre><code>openssl genrsa -out ca.key 1024 //生成私钥
openssl req -new -key ca.key -out rsacert.csr //创建证书请求
openssl x509 -req -days 3650 -in rsacert.csr -signkey ca.key -out rsacert.crt //生成证书并签名，有效期10年
openssl x509 -outform der -in rsacert.crt -out rsacert.der //将 PEM 格式文件转换成 DER 格式
openssl pkcs12 -export -out p.p12 -inkey ca.key -in rsacert.crt //入P12文件
</code></pre>

<h4 id="toc_3">安全之签名</h4>

<p>MD5 </p>

<blockquote>
<p>Hash 散列函数不可逆的特点，是“加密”的另一种应用，可实现对安全信息的签名验证和标志文件。【不是正真的加密算法】</p>
</blockquote>

<p>RSA </p>

<blockquote>
<p>RSA算法有两个作用一个是加密一个是数字签名<br/>
数字签名<br/>
    发送方<br/>
        <q>报文</q> HASH 得到 <q>报文摘要</q><br/>
        <q>报文摘要</q> 用公钥加密(数字签名) + 报文<br/>
            发送给接收方<br/>
    接收方<br/>
        <q>报文</q> HASH 得到 <q>报文摘要</q><br/>
        <q>数字签名</q> 用私钥解密 判断是否与 <q>报文摘要</q> 相同</p>
</blockquote>

<h4 id="toc_4">iOS 安全特有功能</h4>

<p>1.手机指纹、密码登录</p>

<blockquote>
<p>1 判断是否有使用指纹或密码验证: - (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError * __autoreleasing *)error <strong>attribute</strong>((swift_error(none)));<br/>
policy 分为: LAPolicyDeviceOwnerAuthenticationWithBiometrics 和 LAPolicyDeviceOwnerAuthentication， 前者只使用指纹，后者在指纹失败后会弹出密码验正。<br/>
2 请求验证，弹出验证界面 - (void)evaluatePolicy:(LAPolicy)policy localizedReason:(NSString *)localizedReason reply:(void(^)(BOOL success, NSError * error))reply;<br/>
3 验证结果，如果 success 是YES标志验证成功，NO标志不成功。 当验证不成共时，error 有： </p>

<blockquote>
<p>3.1 LAErrorAuthenticationFailed - 指纹无法识别<br/>
3.2 LAErrorUserCancel     --用户点击了取消<br/>
3.3 LAErrorUserFallback   --用户点击了输入密码<br/>
3.4 LAErrorSystemCancel   --系统取消<br/>
3.5 LAErrorPasscodeNotSet --因为你设备上没有设置密码<br/>
3.6 LAErrorTouchIDNotAvailable  --设备没有Touch ID<br/>
3.7 LAErrorTouchIDNotEnrolled   --因为你的用户没有输入指纹<br/>
3.8 LAErrorTouchIDLockout --多次输入，密码锁定<br/>
3.9 LAErrorAppCancel--    比如电话进入，用户不可控的</p>
</blockquote>
</blockquote>

<p>2.钥匙串：保存安全性很高的小数据，他还具有一次保存，长久保留【删除应用后还存在】的特点</p>

<h4 id="toc_5">iOS 中重要的函数</h4>

<p>1.非对称加密函数</p>

<blockquote>
<p>SecKeyEncrypt 使用公钥对数据加密<br/>
SecKeyDecrypt 使用私钥对数据解密<br/>
SecKeyRawVerify 使用公钥对数字签名进行验证<br/>
SecKeyRawSign  使用私钥生成数字签名</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-09T13:40:41+08:00" itemprop="datePublished">2018/6/9</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%B7%A5%E5%85%B7.html'>工具</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15285228410744.html" itemprop="url">
		windows 操作系统使用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>常用快捷键</p>

<blockquote>
<p>1.Windows + Tab 切换应用窗口<br/>
2.Ctr 控制键， Ctr + C 复制， Ctr + V 粘贴  Ctr + N 是新建一个东西<br/>
3.Alt 交换件 Alt + 左右箭头可以前进或者后退<br/>
4.Shift 大小写转换键<br/>
5.&lt;- -&gt; 左右箭头可以前进或者后退<br/>
 Delete + Enter 可以删除文件，常用在拍照后筛选图片</p>
</blockquote>

<p>QQ 浏览器快捷键<br/>
1. Ctr + N 可以新打开一个窗口<br/>
2. Ctr + T 可以在本窗口在打开一个标签<br/>
3. 关闭当前标签用 Ctr + W<br/>
4. 切换标签用 Ctr + Shift + Tab 向左<br/>
5. 如果想把这个标签的内容截成图片，就是用 Ctr + M，但是只想截取一部分用 Ctr + Shift + X<br/>
6. 前进或者后退 用 Alt + 左右箭头</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-09T08:32:08+08:00" itemprop="datePublished">2018/6/9</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%B7%A5%E5%85%B7.html'>工具</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15285043283743.html" itemprop="url">
		Mac 搭建 简易的 Apache 服务器</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4 id="toc_0">目的：可以很方便的模拟服务器数据，其好处有:</h4>

<blockquote>
<p>1.不需要等待服务器的开发，可以先行写测试数据。【测试数据的好处】<br/>
2. 相对于本地项目中添加的假数据，一是数据来源的流程更真实，不需要添加额外的代码，二是不需要添加假数据，不会污染本地项目，如果在项目完成后没有即使清理假数据，会成为项目的垃圾。<br/>
3. 数据管理更加方便、灵活。</p>
</blockquote>

<h4 id="toc_1">步骤</h4>

<blockquote>
<p>1.在用户目录下创建 Sites 文件夹，创建的文件夹会有浏览器的图标。<br/>
2. Commend + Shift + G 打开前往文件夹窗口, 粘贴 /etc/apache2/ 前往到 apache2<br/>
3. 复制一份httpd.conf 放在当前文件夹，以防改错了可以很方便改回来，然后在拷贝一份httpd.conf 放到桌面，方便修改。<br/>
4. 用文字、代码编辑器编辑httpd.conf<br/>
4.1 搜索DocumentRoot 和 DocumentRoot 改成 /User/ChiCo/Sites 【注释：也就是Sites的位置】<br/>
4.2 搜索Options 找到  Options FollowSymLinks Multiviews  在 Options 后加 Indexes <br/>
4.3 搜索php 找到那一行，去掉前面的注释 #<br/>
4.4 httpd.conf 修改完成，保存一下<br/>
5. Commend + Shift + G 然后 /etc/apache2/ 再次去 apache2， 用桌面的 httpd.conf 替换掉里面的<br/>
6. 回到上一层文件夹, 拷贝php.ini.default 名字改成php.ini 放在当前文件夹<br/>
7. 所有的修改完成，启动一下Apache 服务器， 终端输入 sudo apachectl -k start<br/>
8. 验证是否配置好服务器，打开任意浏览器，输入localhost 或者 127.0.0.1</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-07T16:10:53+08:00" itemprop="datePublished">2018/6/7</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15283590530292.html" itemprop="url">
		多线程与线程安全</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4 id="toc_0">1.线程安全的维度</h4>

<blockquote>
<p>1.线程间安全，不会产生线程死锁、由线程操作产生的异常崩溃<br/>
2.线程数据安全，对于同时可读可写的数据，需要有同步操作</p>
</blockquote>

<h4 id="toc_1">2. 看一个多个线程同时读写操作一个变量的例子</h4>

<pre><code>@property (nonatomic,strong)NSString *target;

// queue 是并发对垒
for (int  index = 0; index &lt; 1000; index++) {
        dispatch_async(queue, ^{
            //如果是并行队列里边 改变同一块内存要加锁
            self.target = [NSString stringWithFormat:@&quot;ksddkjalkjd%d&quot;,index];
            NSLog(@&quot;%@&quot;,self.target);
        });
 }

</code></pre>

<p>这段代码存在的问题</p>

<blockquote>
<p>1.target 打印的数据有肯能不是按顺序的，也就是说数据会错乱<br/>
2.程序崩溃. 原因：</p>

<blockquote>
<p>在iOS中 一个变量在获取新值之前要释放以前的旧址<br/>
  在并行访问同一块资源的时候 如果释放了一次旧址 再次释放就会导致过度释放<br/>
  过度释放会让程序崩溃 报BAD_ACCESS_ADDRESS</p>
</blockquote>
</blockquote>

<p>这类问题我们需要用线程同步来处理，线程同步常用方法有:</p>

<blockquote>
<ol>
<li> 互斥锁和读写锁：提供对临界资源的保护，当多线程试图访问临界资源时，都必须通过获取锁的方式来访问临界资源。（临界资源：是被多线程共享的资源）当读写线程获取锁的频率差别不大时，一般采用互斥锁，如果读线程访问临界资源的频率大于写线程，这个时候采用读写锁较为合适，读写锁允许多个读线程同时访问临界资源，读写线程必须互斥访问临界资源。读写锁的实现采用了互斥锁，所以在读写次数差不多的情况下采用读写锁性能没有直接采用互斥锁来的高。</li>
<li>条件变量：提供线程之间的一种通知机制，当某一条件满足时，线程A可以通知阻塞在条件变量上的线程B，B所期望的条件已经满足，可以解除在条件变量上的阻塞操作，继续做其他事情。</li>
<li>信号量：提供对临界资源的安全分配。如果存在多份临界资源，在多个线程争抢临界资源的情况下，向线程提供安全分配临界资源的方法。如果临界资源的数量为1，将退化为锁。</li>
<li>令牌：一种高级的线程同步的方法。它既提供锁的安全访问临界资源的功能，又利用了条件变量使得线程争夺临界资源时是有序的。</li>
</ol>
</blockquote>

<h4 id="toc_2">3.线程同步导致死锁</h4>

<p>例如: 1.线程循环等待导致死锁</p>

<pre><code>//当前是主队列
dispatch_sync(dispatch_get_main_queue(), ^{
            
 });
 // 如果是非主队列也如此
dispatch_queue_t queue = dispatch_queue_create(&quot;gcd&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{
  NSLog(@&quot;外边的1 %@&quot;,[NSThread currentThread]);
  dispatch_sync(queue, ^{
      NSLog(@&quot;里边的 %@&quot;,[NSThread currentThread]);
            
        });
      NSLog(@&quot;外边的2 %@&quot;,[NSThread currentThread]);
        
});
</code></pre>

<p>2.线程同步时资源竞争</p>

<blockquote>
<p>例如 下图左右两个线程要使用独立的两个资源A和B，而且只有在代码块结束后才让别的线程使用A、B两种资源，当A和B分别被这两个线程得到后，在执行1和2两步后，线程会死锁，一直等待他们需要的资源 <br/>
<img src="media/15283590530292/15290485148371.jpg" alt=""/></p>
</blockquote>

<p>解决方法</p>

<blockquote>
<p>1.资源的加锁范围尽量缩小，也就是可以不占用后立马释放<br/>
2.加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<br/>
3. 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-06T14:46:41+08:00" itemprop="datePublished">2018/6/6</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15282676008575.html" itemprop="url">
		函数研究</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>C 代码</p>

<pre><code>int sum(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
    return a + b  + c + d + e + f + g + h + i;
}

int main(int argc, char * argv[]) {
    int c = sum(1,2,3,4,5,6,7,8,9);
    printf(&quot;%d&quot;,c);
}

</code></pre>

<p>运行时截取的汇编代码</p>

<pre><code>    0x1044d0f00 &lt;+0&gt;:   sub    sp, sp, #0x30             ; =0x30 
    0x1044d0f04 &lt;+4&gt;:   stp    x29, x30, [sp, #0x20]
    0x1044d0f08 &lt;+8&gt;:   add    x29, sp, #0x20            ; =0x20 
    0x1044d0f0c &lt;+12&gt;:  orr    w8, wzr, #0x1
    0x1044d0f10 &lt;+16&gt;:  orr    w9, wzr, #0x2
    0x1044d0f14 &lt;+20&gt;:  orr    w2, wzr, #0x3
    0x1044d0f18 &lt;+24&gt;:  orr    w3, wzr, #0x4
    0x1044d0f1c &lt;+28&gt;:  mov    w4, #0x5
    0x1044d0f20 &lt;+32&gt;:  orr    w5, wzr, #0x6
    0x1044d0f24 &lt;+36&gt;:  orr    w6, wzr, #0x7
    0x1044d0f28 &lt;+40&gt;:  orr    w7, wzr, #0x8
    0x1044d0f2c &lt;+44&gt;:  mov    w10, #0x9
    0x1044d0f30 &lt;+48&gt;:  stur   w0, [x29, #-0x4]
    0x1044d0f34 &lt;+52&gt;:  str    x1, [sp, #0x10]
-&gt;  0x1044d0f38 &lt;+56&gt;:  mov    x0, x8
    0x1044d0f3c &lt;+60&gt;:  mov    x1, x9
    0x1044d0f40 &lt;+64&gt;:  str    w10, [sp]
    0x1044d0f44 &lt;+68&gt;:  bl     0x1044d0e88               ; sum at main.m:12
    0x1044d0f48 &lt;+72&gt;:  str    w0, [sp, #0xc]
    0x1044d0f4c &lt;+76&gt;:  ldr    w8, [sp, #0xc]
    0x1044d0f50 &lt;+80&gt;:  mov    x30, x8
    0x1044d0f54 &lt;+84&gt;:  mov    x11, sp
    0x1044d0f58 &lt;+88&gt;:  str    x30, [x11]
    0x1044d0f5c &lt;+92&gt;:  adrp   x0, 184
    0x1044d0f60 &lt;+96&gt;:  add    x0, x0, #0xebf            ; =0xebf 
    0x1044d0f64 &lt;+100&gt;: bl     0x10457cd14               ; symbol stub for: printf
    0x1044d0f68 &lt;+104&gt;: mov    w8, #0x0
    0x1044d0f6c &lt;+108&gt;: str    w0, [sp, #0x8]
    0x1044d0f70 &lt;+112&gt;: mov    x0, x8
    0x1044d0f74 &lt;+116&gt;: ldp    x29, x30, [sp, #0x20]
    0x1044d0f78 &lt;+120&gt;: add    sp, sp, #0x30             ; =0x30 
    0x1044d0f7c &lt;+124&gt;: ret    

</code></pre>

<blockquote>
<p>sp, sp, #0x30   // 栈从 0x1044d0f00 向上拉升 #0x30 </p>

<p>通过观察，我们不难发现 sum(3, 5) 函数的参数3,5 在汇编中是通过两个寄存器传递的<br/>
orr    w8, wzr, #0x3<br/>
mov    w9, #0x5<br/>
然后到了sum 函数的内部，又通过sp 将数据保存到了栈<br/>
w0, [sp, #0xc]<br/>
ldr    w8, [sp, #0xc]</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-06T07:32:47+08:00" itemprop="datePublished">2018/6/6</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15282415674401.html" itemprop="url">
		iOS 与多线程</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<blockquote>
<p>· NSThread 可以直接操作线程<br/>
· GCD: Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。<br/>
· NSOperation 在GCD之上的封装，更适合添加操作之间的依赖关系。</p>
</blockquote>

<h3 id="toc_0">NSThread 常用点</h3>

<ol>
<li>setName 可以定义线程的名字，方便跟踪和调试</li>
<li>[NSThread currentThread] 可以看当前操作的线程</li>
</ol>

<pre><code> NSThread *thread = [[NSThread alloc] initWithTarget:self
                                               selector:@selector(threadTest)
                                                 object:nil];
[thread setName:@&quot;EasyIOSThread&quot;];
[thread start];
</code></pre>

<p><img src="media/15282415674401/15282447513933.jpg" alt=""/><br/>
3.最厉害的一点，他可以直接让线程死亡，也就是当前没做完的操作立马终止</p>

<pre><code>[thread exit];
</code></pre>

<h3 id="toc_1">GCD</h3>

<ol>
<li>dispatch queue</li>
</ol>

<blockquote>
<p>任务间执行的方式<br/>
DISPATCH_QUEUE_CONCURRENT 并行 <br/>
DISPATCH_QUEUE_SERIAL_INACTIVE 串行<br/>
同步异步<br/>
dispatch_async 开启异步队列，具备开启线程的能力<br/>
dispatch_sync  开启同步队列，不会开辟新的线程</p>
</blockquote>

<p>1.并行异步</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;gcd1.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;gcd1.queue %@&quot;,[NSThread currentThread]);
        }
    });
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;gcd2.queue %@&quot;,[NSThread currentThread]);
        }
    });
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;gcd3.queue %@&quot;,[NSThread currentThread]);
        }
    });
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;gcd4.queue %@&quot;,[NSThread currentThread]);
        }
    });
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;gcd5.queue %@&quot;,[NSThread currentThread]);
        }
    });
</code></pre>

<p>执行结果</p>

<pre><code> 1.gcd1 gcd2 gcd3 gcd4  gcd5 会随机的打印，也就说是同时执行
 2.[NSThread currentThread] 不是主线程，且有多个线程
</code></pre>

<blockquote>
<p>dispatch_async 会从当前的线程切换到新的线程， DISPATCH_QUEUE_CONCURRENT 并发执行，异步并发的线程会开启多条线程，线程的数量由任务数量、系统可分配线程数共同决定</p>
</blockquote>

<p>串行异步</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;gcd1.queue&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 100; index++) {
            NSLog(@&quot;gcd1.queue&quot;);
        }
    });
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 100; index++) {
            NSLog(@&quot;gcd2.queue&quot;);
        }
    });
</code></pre>

<p>执行结果</p>

<pre><code>1.gcd1 打印完成后才接着打印gcd2
2.不是在主线程，线程打印输出 &lt;NSThread: 0x60400047f500&gt;{number = 8, name = null}
</code></pre>

<p>并行同步</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;gcd1.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_sync(queue, ^{
        for (int index = 0; index &lt; 100; index++) {
            NSLog(@&quot;gcd1.queue %@&quot;,[NSThread currentThread]);
        }
    });
    dispatch_sync(queue, ^{
        for (int index = 0; index &lt; 100; index++) {
            NSLog(@&quot;gcd2.queue %@&quot;,[NSThread currentThread]);
        }
    });
</code></pre>

<p>串行同步</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;gcd1.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_sync(queue, ^{
        for (int index = 0; index &lt; 100; index++) {
            NSLog(@&quot;gcd1.queue %@&quot;,[NSThread currentThread]);
        }
    });
    dispatch_sync(queue, ^{
        for (int index = 0; index &lt; 100; index++) {
            NSLog(@&quot;gcd2.queue %@&quot;,[NSThread currentThread]);
        }
    });
</code></pre>

<p>执行结果</p>

<pre><code>1. 都是在当前线程执行，调试的时候是在主线程，所以打印显示的是 mian 线程
2. 任务是顺序打印的
</code></pre>

<blockquote>
<p>因为是同步任务，所以不会从线程池获取线程，只是使用当前线程，任务就只能一个执行完成后在执行其他的任务</p>
</blockquote>

<p>小结</p>

<blockquote>
<p>队列执行方式<br/>
串行队列是一个任务一个任务顺序执行<br/>
并行队列是可以同时调度多个任务<br/>
 *<br/>
任务开启方式<br/>
同步执行：不会到线程池里边获取子线程<br/>
异步执行：只要有任务，就会去获取新线程 【主队列只有一条线程，除外】</p>
</blockquote>

<h4 id="toc_2">两个重要的队列</h4>

<blockquote>
<p>dispatch_get_global_queue 全局队列，他是一个并发的队列<br/>
dispatch_get_main_queue() 主队列，他是串行的队列【有且只有主线程】  </p>
</blockquote>

<pre><code>for (int index = 0; index &lt; 5; index ++) {
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            NSLog(@&quot;dispatch_async %@ %d&quot;,[NSThread currentThread],index);
        });
        
        dispatch_sync(dispatch_get_global_queue(0, 0), ^{
            NSLog(@&quot;dispatch_sync %@ %d&quot;,[NSThread currentThread],index);
        });
        
        NSLog(@&quot;come here %d&quot;,index);
    }
</code></pre>

<p>运行结果</p>

<pre><code>1. dispatch_sync 是在当前线程执行的 线程打印为&lt;NSThread: 0x604000072980&gt;{number = 1, name = main}
2. dispatch_async 不是在当前线程执行的，线程打印为 &lt;NSThread: 0x60000047ed00&gt;{number = 3, name = (null) 和 &lt;NSThread: 0x604000660340&gt;{number = 4, name = (null)
3. come here 的调用顺序始终在dispatch_sync之后
4. dispatch_sync 和 dispatch_async 打印随机，也就是说主线程和其他线程交替执行
</code></pre>

<p>单看 dispatch_async</p>

<blockquote>
<p>异步的多个dispatch_get_global_queue 可以在多条线程并发执行<br/>
同步的只能在当前线程执行 (come here 总是在 dispatch_sync)</p>
</blockquote>

<p>dispatch_get_main_queue() 常用地方 - 从别的线程回到主线程</p>

<pre><code>// to main
dispatch_async(dispatch_get_main_queue(), ^{
            
 });
</code></pre>

<p>GCD 线程切换注意点：不能用同步的方式切换到同一个串行队列<br/>
例如：</p>

<pre><code>// current queue is main queue
dispatch_sync(dispatch_get_main_queue(), ^{
            
 });
 // 如果是非主队列也如此
dispatch_queue_t queue = dispatch_queue_create(&quot;gcd&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{
        
        NSLog(@&quot;外边的1 %@&quot;,[NSThread currentThread]);
        dispatch_sync(queue, ^{
            NSLog(@&quot;里边的 %@&quot;,[NSThread currentThread]);
            
        });
        NSLog(@&quot;外边的2 %@&quot;,[NSThread currentThread]);
        
    });
 //但是并发的队列不会死锁
 dispatch_queue_t queue = dispatch_queue_create(&quot;gcd&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{
        
        NSLog(@&quot;外边的1 %@&quot;,[NSThread currentThread]);
        dispatch_sync(queue, ^{
            NSLog(@&quot;里边的 %@&quot;,[NSThread currentThread]);
            
        });
        NSLog(@&quot;外边的2 %@&quot;,[NSThread currentThread]);
        
  });
</code></pre>

<blockquote>
<p>原因<br/>
1. 串行队列的任务是顺序执行的，需要等到前面已经入队的任务执行完然后在执行后续任务<br/>
2. 同步执行是在当前的队列立马执行任务<br/>
3. 在串行的队列里边执行同步任务，这个同步任务是在队列的中间插入的，从队列的执行顺序看，这个同步任务需要等到他前面的任务执行完成后在执行，但是同步任务自身又是不能等待的，他要立马执行。两者就产生了死锁。<br/>
4. 从dispatch_sync(dispatch_get_main_queue(), ^{}); 产生死锁我们也可以确定主队列是串行的</p>
</blockquote>

<p>重要方法 1. dispatch_group_t group, 在dispatch_group_notify 可以让任务完成后返回</p>

<pre><code> dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_queue_create(&quot;download_queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_async(group, queue, ^{
        for (int index = 0; index &lt; 3; index ++) {
            NSLog(@&quot;first task %d&quot;,index);
        }
    });
    dispatch_group_async(group, queue, ^{
        for (int index = 0; index &lt; 3; index ++) {
            NSLog(@&quot;second task %d&quot;,index);
        }
    });
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;task finish&quot;);
    });
</code></pre>

<pre><code>[第280行]: second task 0
[第275行]: first task 0
[第280行]: second task 1
[第275行]: first task 1
[第280行]: second task 2
[第275行]: first task 2
[第284行]: task finish
</code></pre>

<p>dispatch_barrier_sync 和  dispatch_barrier_async 栅栏函数</p>

<pre><code> dispatch_queue_t queue = dispatch_queue_create(&quot;gcd1.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;11111&quot;);
        }
    });
    
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;22222&quot;);
        }
    });
    
    dispatch_barrier_sync(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;dispatch_barrier_sync %@&quot;,[NSThread currentThread]);
        }
        return ;
    });
    NSLog(@&quot;----&quot;);
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;33333&quot;);
        }
    });
    dispatch_async(queue, ^{
        for (int index = 0; index &lt; 10; index++) {
            NSLog(@&quot;44444&quot;);
        }
    });
</code></pre>

<p>执行结果</p>

<pre><code>1. 1111 和 2222 随机打印
2. 打印 dispatch_barrier_sync
3. 打印 ----
4. 33333 和  44444 随机打印
</code></pre>

<blockquote>
<p>小结<br/>
dispatch_barrier_sync 和 dispatch_barrier_async 都会将前后的任务隔开，并且要等到前边的任务执行完后，在执行栅栏里边的任务，然后执行后边的任务。<br/>
区别是 sync 是同步的， 也就是说当前的线程执行到dispatch<u>barrier</u>sync 时会去执行这个队列里的任务【如果当前队列和当前的线程是一个，会死锁】 dispatch_async 是异步的，不需要切换到该队列去执行</p>
</blockquote>

<p>NSOperation 可以很方便管理任务之间的依赖</p>

<pre><code>    self.queue = [[NSOperationQueue alloc] init];
    [self.queue setName:@&quot;qk.queue.com&quot;];
    
    //第一条线
    NSInvocationOperation *firstOperation
    = [[NSInvocationOperation alloc]
       initWithTarget:self
       selector:@selector(firstStep)
       object:nil];
    
    [firstOperation setName:@&quot;qk.queue.firstOperation&quot;];
    
    //第二条线
    NSInvocationOperation *secondOperation
    = [[NSInvocationOperation alloc] initWithTarget:self
                                           selector:@selector(secondStep)
                                             object:nil];
    
    [secondOperation setName:@&quot;qk.queue.secondOperation&quot;];
    
    
    //前面的要在后边的执行完成后才能够执行
    [secondOperation addDependency:firstOperation];
    
    //如果没有添加依赖关系 operation 会并发执行
    [self.queue addOperation:secondOperation];
    [self.queue addOperation:firstOperation];
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-05T21:00:56+08:00" itemprop="datePublished">2018/6/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15282036563173.html" itemprop="url">
		汇编指令练习</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">bl指令</h3>

<ul>
<li>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令</li>
<li>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如

<ul>
<li>mov x0,#10、mov x1,#20</li>
</ul></li>
<li><p>但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p></li>
<li><p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p></li>
</ul>

<h3 id="toc_1">bl指令 -- 练习</h3>

<p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p>

<pre><code>_A:
    mov x0,#0xa0
    mov x1,#0x00
    add x1, x0, #0x14
    mov x0,x1
    bl _B
    mov x0,#0x0
    ret

_B:
    add x0, x0, #0x10
    ret
</code></pre>

<p><img src="media/15282036563173/15282051792907.jpg" alt=""/></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-05T15:10:29+08:00" itemprop="datePublished">2018/6/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15281826293684.html" itemprop="url">
		汇编与硬件</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">总线</h3>

<ul>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互</li>
<li>总线：一根根导线的集合</li>
<li><p>总线的分类</p>

<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul></li>
<li><p><strong>地址总线</strong></p>

<ul>
<li>它的宽度决定了CPU的<u>寻址能力</u></li>
<li>8086的地址总线宽度是<u>20</u>，所以寻址能力是<u>1M</u>（ 2<sup>20</sup>  ）</li>
</ul></li>
<li><p><strong>数据总线</strong></p>

<ul>
<li>它的宽度决定了CPU的单次数据传送量，也就是数据<u>传送速度</u></li>
<li>8086的数据总线宽度是<u>16</u>，所以单次最大传递<u>2个字节</u>的数据</li>
</ul></li>
<li><p><strong>控制总线</strong></p>

<ul>
<li>它的宽度决定了CPU对其他器件的<u>控制能力</u>、能有多少种控制</li>
</ul></li>
</ul>

<p><strong>做个小练习</strong><br/>
* 一个CPU 的寻址能力为8KB,那么它的地址总线的宽度为？</p>

<blockquote>
<p>8KB = 2<sup>3KB</sup> = 2<sup>3</sup> * 2<sup>10</sup> Byte = 2<sup>13</sup> Byte<br/>
8KB 的地址总线宽度为13<br/>
注意：内存的最小的存储单位是Byte，而不是一个bit，也就是说一个地址线可以访问1Byte的空间</p>
</blockquote>

<ul>
<li>8080,8088,80286,80386 的<strong>地址总线</strong>宽度分别为16根,20根,24根,32根.那么他们的寻址能力分别为多少____KB, ____MB,____MB,____GB?</li>
</ul>

<blockquote>
<p>1KB = 2<sup>10</sup> Byte  =&gt; 2<sup>16</sup> Byte = 2<sup>10</sup> * 2<sup>6</sup> Byte = 2<sup>6</sup> KB = 64KB<br/>
1 MB = 2<sup>10</sup> KB = 2<sup>10</sup> * 2<sup>10</sup> Byte = 2<sup>20</sup> Byte<br/>
2<sup>24</sup> Byte = 2<sup>20</sup> * 2<sup>4</sup> Byte = 2<sup>4</sup> MB = 16MB<br/>
1 GB = 2<sup>10</sup> MB = 2<sup>10</sup> * 2<sup>20</sup> Byte = 2<sup>30</sup> Byte ==&gt; 2<sup>32</sup> Byte = 2<sup>2</sup> GB = 4GB</p>
</blockquote>

<ul>
<li>8080,8088,8086,80286,80386 的<strong>数据总线</strong>宽度分别为8根,8根,16根,16根,32根.那么它们一次可以传输的数据为:____B,____B,____B,____B,____B</li>
</ul>

<blockquote>
<p>注意，地址总线用于寻址，而一个地址存的是一个Byte大小的数据<br/>
数据总线用于传递数据，一个数据总线可以传一个二进制的数据，0或者1，所以是一个bite<br/>
数据总线的传输率是所有线路量之和<br/>
8bit = 1Byte<br/>
16Bit = 2Byte <br/>
32Bit = 4Byte</p>
</blockquote>

<ul>
<li>从内存中读取1024字节的数据,8086至少要读____次,80386至少要读取____次.
&gt; 8086 需要 1024 / 2 = 512 次
&gt; 80386 至少需要 1024/4 = 256 次</li>
</ul>

<h3 id="toc_1">内存</h3>

<ul>
<li><p>内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2<sup>20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB</sup></p></li>
<li><p>0x00000~0x9FFFF：主存储器。可读可写</p></li>
<li><p>0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写</p></li>
<li><p>0xC0000~0xFFFFF：存储各种硬件\系统信息。只读</p></li>
</ul>

<h3 id="toc_2">数据的宽度</h3>

<p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p>

<pre><code class="language-objc">#import &lt;UIKit/UIKit.h&gt;
#import &quot;AppDelegate.h&quot;

int test(){
    int cTemp = 0x1FFFFFFFF;
    return cTemp;
}

int main(int argc, char * argv[]) {
    printf(&quot;%x\n&quot;,test());
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>

<h3 id="toc_3">寄存器</h3>

<p><strong>内部部件之间由总线连接</strong><br/>
<img src="media/15281826293684/15281920704878.jpg" alt=""/></p>

<ul>
<li>可以通过寄存器找到对应的数据，对项目的调试、追踪是很重要的</li>
<li>不同的CPU，寄存器的个数、结构是不相同的</li>
</ul>

<h3 id="toc_4">通用寄存器</h3>

<ul>
<li><p>ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）</p>

<ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!
<img src="media/15281826293684/15281933267797.jpg" alt=""/></li>
</ul></li>
<li><p>通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算</p></li>
<li><p>也就是说寄存器只负责存东西，至于计算交给CPU</p></li>
</ul>

<h3 id="toc_5">pc寄存器(program counter)</h3>

<p><img src="media/15281826293684/15281935199483.jpg" alt=""/></p>

<ul>
<li>为指令指针寄存器，它指示了CPU当前要读取指令的地址</li>
<li>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</li>
<li>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义

<ul>
<li>比如 1110 0000 0000 0011 0000 1000 1010 1010 </li>
<li>可以当做数据   0xE003008AA </li>
<li>也可以当做指令  mov    x0, x8</li>
</ul></li>
<li>CPU根据什么将内存中的信息看做指令？

<ul>
<li>CPU将pc指向的内存单元的内容看做指令</li>
<li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li>
</ul></li>
</ul>

<p><img src="media/15281826293684/482DD597-1D2D-4828-A431-4EF46DAAD3F0.png" alt="482DD597-1D2D-4828-A431-4EF46DAAD3F0"/></p>

<p><img src="media/15281826293684/6046E81D-CE1A-479C-A2A9-11596D9781F0.png" alt="6046E81D-CE1A-479C-A2A9-11596D9781F0"/></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-05T10:33:04+08:00" itemprop="datePublished">2018/6/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15281659843189.html" itemprop="url">
		线程和多线程理论</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">1.线程和多线程定义</h3>

<blockquote>
<p>线程是程序中一个单一的顺序控制流程。进程内有一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指令运行时的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p>
</blockquote>

<h3 id="toc_1">2.线程和进程的区别</h3>

<blockquote>
<p>1.进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。<br/>
2.进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。<br/>
3.与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。<br/>
4.线程是进程中的一个单元，他是不能独立运行的，他必须依赖某个进程。</p>
</blockquote>

<h3 id="toc_2">3.使用多线程的原因</h3>

<blockquote>
<p>·使用线程可以把占据时间长的程序中的任务放到后台去处理<br/>
·用户界面的更新和交互是不能被阻塞的，耗时操作是不能放在主线程的<br/>
·当CPU是多核的时候，不同的进程可以实现并行，这样就提高了程序的运行效率<br/>
·有些任务并不是连续的，需要等待，比如网络收发数据、用户输入等, 这些操作并不需要等到执行完成，二是需要有变化才操作。</p>
</blockquote>

<h4 id="toc_3">4 多线程使用注意事项</h4>

<p>4.1 开辟过多线程的问题</p>

<blockquote>
<p>·系统需要为线程开辟存储空间来管理他，线程过多，会占用大量内存。<br/>
·线程是通过CPU来调度的，过多的线程会加大CPU的负担，会增加耗电量，还会让机器发烫。</p>
</blockquote>

<p>4.2 其他问题</p>

<blockquote>
<p>·多个线程同时访问同一数据的访问，要确保数据的安全<br/>
·线程死锁</p>
</blockquote>

<h4 id="toc_4">5 线程的生命周期</h4>

<p><img src="media/15281659843189/15282400739519.jpg" alt=""/></p>

<blockquote>
<p>1.线程创建后放到等待队列中，等待CPU的调度，所以新建只有到就绪一种转换。<br/>
2.就绪的是在等待的过程中，没有被CPU执行，不会和其他的线程争夺资源，所以会会变成阻塞状态，只会在运行的状态里切换。<br/>
3.运行的线程可以变成就绪、阻塞或者死亡的状态，当时间片到后，线程会进入到就绪状态，当某个线程得不到资源，会被阻塞，当线程执行完成后，线程会死亡。<br/>
4.线程死亡后，不会保留线程相关信息，会释放掉占用的内存，所以死亡的线程是无法逆转的。就不可以转成其他几种状态。</p>
</blockquote>

<h4 id="toc_5">6 线程间的通讯</h4>

<p>线程间的通信机制实现起来则相对简单，主要包括互斥锁、条件变量、读写锁和线程信号等。<br/>
6.1 互斥锁</p>

<blockquote>
<p>互斥锁基本原理：互斥锁以排他的方式防止数据被并发修改。当多个线程共享相同的内存时，需要确保每个线程看到的数据是一样的。如果是只读，那么一定是一样的。如果是可读可写，在一个线程操作一个内存区域时，包含三个步骤，即读出数据，修改数据，写回数据。如果该线程在没有写回数据前，另一个线程来访问同一个区域，如果是读，得不到最新的数据状态，如果是写，则会造成数据覆盖等问题。[12306购票]<br/>
 互斥锁就两个状态：开锁（0），上锁（1）。将某个共享资源和互斥锁绑定后，对该共享资源的访问操作如下：<br/>
 A】在访问资源前，首先申请该互斥锁，如果在开锁状态，则申请到该锁对象，并立即占有该锁（锁定）。以防其他线程访问修改此资源。如果该锁处于锁定状态，默认阻塞等待。<br/>
B】原则上只有锁定该互斥锁的进程才能释放此互斥锁</p>
</blockquote>

<p>6.2 条件变量</p>

<blockquote>
<p>条件变量通信机制：<br/>
1、条件变量基本原理：条件变量的出现，可以弥补互斥锁的缺陷，有些问题仅仅靠互斥锁无法解决。但是条件变量不能单独使用，必须配合互斥锁一起实现对资源的互斥访问</p>
</blockquote>

<p>6.2 读写锁</p>

<blockquote>
<p>1、读写锁基本原理：在对数据的读写操作时，往往是读占主要部分。为了满足当前能够允许多个读出，但只允许一个写入的需求。线程提供了读写锁来实现。读写锁基本原则如下：<br/>
 A】如果有其他线程读数据，则允许其他线程执行读操作，但是不允许写操作。<br/>
 B】如果有其他线程申请了写锁，则其他线程既不能申请读锁，也不能申请写锁</p>
</blockquote>

<p>6.3 线程信号：</p>

<blockquote>
<p>线程是一种轻量级的进程，因此进程的信号同样适用于线程。不过相对于进程信号，线程拥有与信号相关的私有数据——线程信号掩码，则就决定了线程在信号操作时具有以下特性：<br/>
  A】每个线程可以先别的线程发送信号，pthread<u>kill（）函数用来完成这一操作。<br/>
  B】每个线程都可以设置自己的阻塞集合。pthread</u>sigmask（）用来完成这一操作。类似于进程中的sigprocmask（）函数。主进程创建出来的线程继承主进程的掩码。<br/>
  C】每个线程需要设置针对某信号的处理方式，但同一个进程中对某信号的处理方式只能有一个有效，即最后一次设置的处理方式。即在所有的线程里，同一信号在任何线程里的对该信号的处理一定相同<br/>
  D】如果别的进程向当前进程发来一个信号，具体由哪个线程去处理，是未知的。</p>
</blockquote>

<p>注：如果有不准确的地方，欢迎大家来吐槽。QQ：1392984568 一米阳光 （iOS 修炼者 ）</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-03T19:35:52+08:00" itemprop="datePublished">2018/6/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%A7%84%E5%88%92.html'>第三方框架</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15280257520553.html" itemprop="url">
		pods 私有库</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">创建本地私有库</h3>

<ol>
<li>pod lib create QKEasyTest
<img src="media/15280257520553/15280808189626.jpg" alt=""/></li>
</ol>

<p>2.配置QKEasyTest git版本管理</p>

<pre><code>cd QKEasyTest
git init
git add . 
git commit -m &quot;first commit&quot; -a
git remote add origin https://gitee.com/yanzhi11/QKEasyTest.git
git push -u origin master
</code></pre>

<p><img src="media/15280257520553/15280818329296.jpg" alt=""/></p>

<p>3.添加你需要的私有库文件<br/>
<img src="media/15280257520553/15280844687860.jpg" alt=""/></p>

<p>4.修改QKEasyTest.podspec 文件 配置源码地址 <br/>
<img src="media/15280257520553/15280849737738.jpg" alt=""/></p>

<p>5.将修改提交到远程仓库，并打一个tag<br/>
<img src="media/15280257520553/15280910601610.jpg" alt=""/><br/>
6.讲QKEasyTest 添加到本地的索引库<br/>
<img src="media/15280257520553/15281026975863.jpg" alt=""/><br/>
然后推到自己的私有库</p>

<p>7.测试一下<br/>
<img src="media/15280257520553/15281028048076.jpg" alt=""/></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-06-03T13:45:58+08:00" itemprop="datePublished">2018/6/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%A7%84%E5%88%92.html'>第三方框架</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15280047582749.html" itemprop="url">
		轮播图</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">实现思路</h3>

<p>1.1: 三个视图，中间的视图用于显示当前播放的图片，左右的视图用于向左向右切换。</p>

<p>1.2: 无限循环的数学思路，以五张图片为例，<code>1</code> &lt;-&gt; <code>2</code> &lt;-&gt; <code>3</code> &lt;-&gt; <code>4</code> &lt;-&gt; <code>5</code> &lt;-&gt; <code>1</code> ... &lt;-&gt;<code>5</code>, 也就是第一张图片向左可以切换到最后一张图片，最后一张图片向右可以切换到第一张图片，然后中间的图片是连续的。我们设有总共有M张图片，那么很容易得到数列 <code>{Sn = (Sn-1 + 1) % M ， S1 = 1，S2 = 2}</code>  也就是说中间的图片是左边的图片 + 1 然后对总图片数取余。</p>

<p>1.3: 一个切换过程的细节，我们以播放下一张为例，当中间的视图被右边的视图切换掉后，此时显示的是过渡视图，我们将左边和中间视图的显示内容向又移动一个单元，也就是说中间的视图和右边的过渡视图此时是一样的，然后改变滚动视图的显示区域，把视图滚动到中间，也就是中间的视图在此霸占了显示区域，重新记录一下我们显示到了第几张图片，以便下次我们切换图片。这样就完成了一个切换，向左切换也是同理。</p>

<h3 id="toc_1">下面是iOS 的实现细节</h3>

<p><img src="media/15280047582749/15280105400096.jpg" alt=""/><br/>
1.主题部分：<br/>
 1.1: bodyView 承载三个 UIImageView, centerImageView 是当前展示的内容，leftImageView和rightImageView负责左右切换的时候显示,切换完成后要还原到centerImageView， 也就以centerImageView 为中心。<br/>
 1.2: page 记录当前滑动到了第几张了，每一次滑动，都会切换三张图片。如刚开始是 <code>1,2,3</code> 向右一个单元后图片变成了 <code>2,3,4</code>,这个page 在每次切换前后都会是起到参考的作用。<br/>
 1.3: imgesCount 图片的总张数， loopSpace: 轮播图的播放间隔，timer 用于自动播放。</p>

<pre><code>@interface QKLoopBanner () &lt;UIScrollViewDelegate&gt;

@property (nonatomic,strong) UIScrollView *bodyView;
@property (nonatomic,strong) UIImageView *leftImageView;
@property (nonatomic,strong) UIImageView *centerImageView;
@property (nonatomic,strong) UIImageView *rightImageView;
@property (nonatomic,strong) UIPageControl *pageControl;

@property (nonatomic,assign) NSUInteger page;
@property (nonatomic,assign) NSUInteger imgesCount;
@property (nonatomic,assign)NSTimeInterval loopSpace;

@property (nonatomic,strong)NSTimer *timer;
@end
</code></pre>

<p>2 播放器和其他类的交互<br/>
2.1: 统一采用代理设计模式，图片点击放在QKLoopBannerDelegate中，点击图片后，会把当前的轮播图（考虑到一个地方可能会有几个轮播图）、当前的显示视图、第几张图片的序号</p>

<pre><code>@class QKLoopBanner;

@protocol QKLoopBannerDelegate &lt;NSObject&gt;

@optional
- (void)loopBanner:(QKLoopBanner *)loopBanner
   didSelectedItem:(UIImageView *)imageView
             index:(NSUInteger)index;

@end
</code></pre>

<p>2.2 轮播图数据源方法<br/>
1. 获取轮播图的总张数<br/>
2. loopBanner:reloadImageView:index 刷新第index张图片，一般会连着调用三次，由于一次轮播。<br/>
3. pageControlOfloopBanner 自定义轮播指示器，如果不想要指示器返回nil就好。<br/>
4. chanedPage 实时报告当前的位置</p>

<pre><code>@protocol QKLoopBannerDataSource &lt;NSObject&gt;

@required
- (NSUInteger)numberOfImagesInLoopBanner:(QKLoopBanner *)loopBanner;
- (void)loopBanner:(QKLoopBanner *)loopBanner
   reloadImageView:(UIImageView *)imageView
             index:(NSUInteger)index;

@optional
- (void)loopBanner:(QKLoopBanner *)loopBanner
        chanedPage:(NSUInteger)page;
- (UIPageControl *)pageControlOfloopBanner:(QKLoopBanner *)loopBanner;

@end
</code></pre>

<p>3 轮播图开放的API<br/>
3.1 initWithFrame:loopSpace 初始化，loopSpace 自动播放时间间隔<br/>
3.2 delegate 交互代理，dataSource 轮播图数据源，数据源必须实现，不然是空白的。<br/>
3.3 reloadData : 当改变了轮播图的张数或者轮播图的具体内容，需要reloadData 重载一下数据。</p>

<pre><code>@interface QKLoopBanner : UIView

- (instancetype)initWithFrame:(CGRect)frame
                    loopSpace:(NSTimeInterval )loopSpace;
- (void)reloadData;


@property (nonatomic,assign) id &lt;QKLoopBannerDelegate&gt; delegate;
@property (nonatomic,assign) id &lt;QKLoopBannerDataSource&gt; dataSource;

@end
</code></pre>

<p>4 实现的具体细节</p>

<pre><code>4.1 通过 dataSource 获取图片张数
- (void)setDataSource:(id&lt;QKLoopBannerDataSource&gt;)dataSource {
    
    _dataSource = dataSource;
    if (_dataSource) {
        self.imgesCount = [dataSource numberOfImagesInLoopBanner:self];
    }
    
}
</code></pre>

<pre><code>4.2 处理 0,1, &gt;1 张的图片
- (void)setImgesCount:(NSUInteger)imgesCount {
    _imgesCount = imgesCount;
    _page = 0;
    switch (imgesCount) {
        case 0:
        {
            //没有图片的情况下，清空所有，不可交互
            [self.leftImageView setImage:nil];
            [self.centerImageView setImage:nil];
            [self.rightImageView setImage:nil];
            [self.bodyView setScrollEnabled:NO];
            [self.centerImageView setUserInteractionEnabled:NO];
            if (self.pageControl) {
                [self.pageControl removeFromSuperview];
                self.pageControl = nil;
            }
        }
            break;
        case 1:
        {
            //只有一张图片的情况下，让中间的视图显示图片，没有自动播放，不可滚动，但是可以点击
            [self.centerImageView setImage:nil];
            [self.rightImageView setImage:nil];
            [self changeToCenter];
            [self.dataSource loopBanner:self
                        reloadImageView:self.centerImageView
                                  index:0];
            [self.centerImageView setUserInteractionEnabled:YES];
            [self.bodyView setScrollEnabled:NO];
            if (self.pageControl) {
                [self.pageControl removeFromSuperview];
                self.pageControl = nil;
            }
        }
            break;
            
        default:
        {
            // 多余一张图片的时候，让中间的显示第一张
            // 让左边的显示最后一张，右边的显示下一张
            // bodyView的视野是中间的那个
            // 播放间隔后自动到下一张
            [self.bodyView setScrollEnabled:YES];
            [self.dataSource loopBanner:self
                        reloadImageView:self.rightImageView
                                  index:imgesCount-1];
            [self.dataSource loopBanner:self
                        reloadImageView:self.centerImageView
                                  index:0];
            [self.dataSource loopBanner:self
                        reloadImageView:self.rightImageView
                                  index:1];
            if ([self.dataSource respondsToSelector:@selector(loopBanner:chanedPage:)]) {
                [self.dataSource loopBanner:self chanedPage:_page];
            }
            [self.centerImageView setUserInteractionEnabled:YES];
            [self.timer setFireDate:[NSDate dateWithTimeIntervalSinceNow:self.loopSpace]];
            if ([self.dataSource respondsToSelector:@selector(pageControlOfloopBanner:)]) {
                self.pageControl = [self.dataSource pageControlOfloopBanner:self];
                [self addSubview:self.pageControl];
                [self.pageControl setNumberOfPages:imgesCount];
            }
        }
            break;
    }
}


</code></pre>

<pre><code>4.3 观察bodyView滚动的位置，当到左边或者右边的时候需要处理
- (void)addObservers {
    [self.bodyView addObserver:self
                    forKeyPath:@&quot;contentOffset&quot;
                       options:NSKeyValueObservingOptionNew
                       context:nil];
}


- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary&lt;NSString *,id&gt; *)change
                       context:(void *)context {
    if ([keyPath isEqualToString:@&quot;contentOffset&quot;]) {
        [self caculatePage];
    }
}

</code></pre>

<p>很关键的点，图片切换前夜 —— 位置计算<br/>
1. criticalValue 为一个很小的正数，这个点子很微妙，说出来就没有韵味了，留给大家慢慢体会。O(∩_∩)O哈哈~<br/>
2. X 坐标 &gt; 2 * CGRectGetWidth(self.bodyView.bounds) 说明是 从中间跑到了 右边， 所以是播放下一张<br/>
3. X 坐标是一个很小的正数，说明已经到第一张了</p>

<pre><code>- (void)caculatePage {
    if (self.imgesCount &gt; 0) {
        CGFloat pointX = self.bodyView.contentOffset.x;
        
        // judge critical value，first and third imageView&#39;s contentoffset
        // last to first or first to last
        CGFloat criticalValue = .2f;
        
     
        if (pointX &gt; 2 * CGRectGetWidth(self.bodyView.bounds) - criticalValue) {
            //centerImage to rightImage(next page)
            // {An | Sn = 1,2,3...n} == {An | Sn = n}
            // {Bn | Sn = 2,3,..n,1} == {Bn | Sn = (n + 1)%n }
            self.page = (self.page + 1) % self.imgesCount;
        } else if (pointX &lt; criticalValue) {
            //scroll to leftImage(previous page)
            // + self.imgesCount mod case for self.page == 0
            self.page = (self.page + self.imgesCount - 1) % self.imgesCount;
        }
    }
}
</code></pre>

<p>图片切换进行时<br/>
1.通过page，刷新左中右视图的显示<br/>
2.把中间的那个视图继续变到中间</p>

<pre><code>- (void)setPage:(NSUInteger)page {
    _page = page;
    NSUInteger leftIndex = (_page + self.imgesCount - 1) % self.imgesCount;
    NSUInteger rightIndex= (_page + 1) % self.imgesCount;
    [self.dataSource loopBanner:self
                reloadImageView:self.leftImageView
                          index:leftIndex];
    [self.dataSource loopBanner:self
                reloadImageView:self.centerImageView
                          index:_page];
    [self.dataSource loopBanner:self
                reloadImageView:self.rightImageView
                          index:rightIndex];
    if ([self.dataSource respondsToSelector:@selector(loopBanner:chanedPage:)]) {
        [self.dataSource loopBanner:self chanedPage:_page];
    }
    [self changeToCenter];
    [self.pageControl setCurrentPage:_page];
}
</code></pre>

<p>自动播放核心<br/>
1.如果中间的视图不在bodyView的视野，先调过来。<br/>
2.从中间位置切换到右边</p>

<pre><code> CGFloat criticalValue = .2f;
    if (self.bodyView.contentOffset.x &lt; CGRectGetWidth(self.bodyView.bounds) - criticalValue || self.bodyView.contentOffset.x &gt; CGRectGetWidth(self.bodyView.bounds) + criticalValue) {
        [self changeToCenter];
    }
    CGPoint newOffset = CGPointMake(self.bodyView.contentOffset.x + CGRectGetWidth(self.bodyView.bounds), self.bodyView.contentOffset.y);
    [self.bodyView setContentOffset:newOffset animated:YES];
</code></pre>

<p>最后，使用到了NSTimer，在轮播图需要释放前，需要先暂停timer，不然会造成内存泄露，切记，在 dealoc 里边是释放不了timer的。内存相关代码如下。</p>

<pre><code>- (void)removeFromSuperview {
    if (self.timer) {
        [self.timer invalidate];
        self.timer = nil;
    }
}
- (void)dealloc {
    [self removeObservers];
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-22T08:35:21+08:00" itemprop="datePublished">2018/5/22</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15269493216963.html" itemprop="url">
		iOS 开发与汇编语言</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><img src="media/15269493216963/15281815572621.jpg" alt=""/></p>

<blockquote>
<ul>
<li> <strong>汇编语言</strong>与<strong>机器语言</strong>一一对应，每一条机器指令都有与之对应的汇编指令</li>
<li> <strong>汇编语言</strong>可以通过编译得到<strong>机器语言</strong>，<strong>机器语言</strong>可以通过反汇编得到<strong>汇编语言</strong></li>
<li> 汇编还原成C的难度要大于C还原成OC</li>
</ul>
</blockquote>

<p>学习汇编的目的 </p>

<blockquote>
<p>·更深入的了解iOS app 运行的过程<br/>
·可以反汇编应用<br/>
·知道反汇编的过程后，会更清晰的认识到应用安全的紧迫性，会采取相应的防护措施<br/>
·为编写高效代码打下基础<br/>
·弄清代码的本质,看系统API的实现过程</p>
</blockquote>

<h3 id="toc_0">机器语言</h3>

<blockquote>
<p>由0和1组成的机器指令.<br/>
* 加：0100 0000<br/>
* 减：0100 1000<br/>
* 乘：1111 0111 1110 0000 <br/>
* 除：1111 0111 1111 0000 </p>
</blockquote>

<h3 id="toc_1">汇编语言(assembly language)</h3>

<blockquote>
<p>使用助记符代替机器语言<br/>
如:<br/>
* 加：INC EAX     通过编译器 0100 0000<br/>
* 减：DEC EAX     通过编译器 0100 1000<br/>
* 乘：MUL EAX         通过编译器 1111 0111 1110 0000<br/>
* 除：DIV EAX     通过编译器 1111 0111 1111 0000</p>
</blockquote>

<h3 id="toc_2">汇编语言的特点</h3>

<blockquote>
<p>*可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能<br/>
* 能够不受编译器的限制，对生成的二进制代码进行完全的控制<br/>
* 目标代码简短，占用内存少，执行速度快<br/>
* 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性<br/>
* 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护<br/>
* 不区分大小写，比如mov和MOV是一样的</p>
</blockquote>

<h3 id="toc_3">汇编语言的种类</h3>

<blockquote>
<ul>
<li>目前讨论比较多的汇编语言有

<ul>
<li>8086汇编（8086处理器是16bit的CPU）</li>
<li>Win32汇编</li>
<li>Win64汇编</li>
<li>ARM汇编（嵌入式、Mac、iOS）</li>
<li>......</li>
</ul></li>
</ul>
</blockquote>

<ul>
<li>我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同.</li>
</ul>

<table>
<thead>
<tr>
<th>架构</th>
<th>设备</th>
</tr>
</thead>

<tbody>
<tr>
<td>armv6</td>
<td>iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td>arm64</td>
<td>iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后</td>
</tr>
</tbody>
</table>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-05T08:25:16+08:00" itemprop="datePublished">2018/5/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E5%BA%95%E5%B1%82.html'>底层</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15254799163209.html" itemprop="url">
		汇编和寄存器</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">关于CPU的补充</h2>

<h4 id="toc_1">寄存器</h4>

<p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>

<blockquote>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
</blockquote>

<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>

<h4 id="toc_2">高速缓存</h4>

<p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>

<blockquote>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个<strong>高速缓存存储区域</strong>.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
</blockquote>

<h3 id="toc_3">寄存器的补充</h3>

<h4 id="toc_4">数据地址寄存器</h4>

<p>数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。<br/>
<strong>ARM64中</strong></p>

<ul>
<li>64位: X0-X30, XZR(零寄存器)</li>
<li>32位: W0-W30, WZR(零寄存器)</li>
</ul>

<blockquote>
<p>注意:<br/>
之前讲解8086汇编中有一种特殊的寄存器段寄存器:CS,DS,SS,ES四个寄存器来保存这些段的基地址,这个属于Intel架构CPU中.在ARM中并没有</p>
</blockquote>

<h4 id="toc_5">浮点和向量寄存器</h4>

<p>因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数</p>

<ul>
<li>浮点寄存器 64位: D0 - D31  32位: S0 - S31</li>
</ul>

<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>

<ul>
<li>向量寄存器 128位:V0-V31</li>
</ul>

<h2 id="toc_6">栈</h2>

<ul>
<li>栈：是一种具有特殊的访问方式的存储空间（后进先出， Last In Out Firt，LIFO）</li>
</ul>

<h3 id="toc_7">SP和FP寄存器</h3>

<ul>
<li>sp寄存器在任意时刻会保存我们栈顶的地址.</li>
<li>fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址!()</li>
</ul>

<blockquote>
<p>注意:ARM64开始,取消32位的 LDM,STM,PUSH,POP指令! 取而代之的是ldr\ldp  str\stp<br/>
ARM64里面 对栈的操作是16字节对齐的!!</p>
</blockquote>

<h3 id="toc_8">关于内存读写指令</h3>

<blockquote>
<p>注意:读/写 数据是都是往高地址读/写</p>
</blockquote>

<p><strong>str(store register)指令</strong></p>

<p>将数据从寄存器中读出来,存到内存中.</p>

<p><strong>ldr(load register)指令</strong></p>

<p>将数据从内存中读出来,存到寄存器中</p>

<p>此ldr 和 str 的变种ldp 和 stp 还可以操作2个寄存器.</p>

<h3 id="toc_9">堆栈操作练习</h3>

<p>使用32个字节空间作为这段程序的栈空间,然后利用栈将x0和x1的值进行交换.</p>

<pre><code>sub    sp, sp, #0x20    ;拉伸栈空间32个字节
stp    x0, x1, [sp, #0x10] ;sp往上加16个字节,存放x0 和 x1
ldp    x1, x0, [sp, #0x10] ;将sp偏移16个字节的值取出来,放入x1 和 x0
</code></pre>

<h2 id="toc_10">bl和ret指令</h2>

<h4 id="toc_11">bl标号</h4>

<ul>
<li>将下一条指令的地址放入lr(x30)寄存器</li>
<li>转到标号处执行指令</li>
</ul>

<h4 id="toc_12">ret</h4>

<ul>
<li>默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址!</li>
</ul>

<blockquote>
<p>ARM64平台的特色指令,它面向硬件做了优化处理的</p>
</blockquote>

<h4 id="toc_13">x30寄存器</h4>

<p>x30寄存器存放的是函数的返回地址.当ret指令执行时刻,会寻找x30寄存器保存的地址值!</p>

<blockquote>
<p>注意:在函数嵌套调用的时候.需要讲x30入栈!</p>
</blockquote>

<h2 id="toc_14">函数的参数和返回值</h2>

<p>ARM64下,<strong>函数的参数</strong>是存放在X0到X7(W0到W7)这8个寄存器里面的.如果超过8个参数,就会入栈.<br/>
<strong>函数的返回值</strong>是放在X0 寄存器里面的.</p>

<h2 id="toc_15">函数的局部变量</h2>

<p>函数的局部变量放在栈里面!</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>